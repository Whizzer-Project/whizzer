--
-- PostgreSQL database dump
--

-- Dumped from database version 10.5
-- Dumped by pg_dump version 12.2

-- Started on 2021-11-24 13:47:15

SET statement_timeout = 0;
SET lock_timeout = 0;
SET idle_in_transaction_session_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = on;
SELECT pg_catalog.set_config('search_path', '', false);
SET check_function_bodies = false;
SET xmloption = content;
SET client_min_messages = warning;
SET row_security = off;

--
-- TOC entry 15 (class 2615 OID 62487)
-- Name: findata; Type: SCHEMA; Schema: -; Owner: findata
--

CREATE SCHEMA findata;


ALTER SCHEMA findata OWNER TO findata;

--
-- TOC entry 379 (class 1255 OID 62560)
-- Name: abortjob(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.abortjob(injobid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history: dd.mon.yyyy  --  author  --   description
  Created:        17.May.2013,DenisaN - 7164
  Description:    Removes one given routing job.Reason:aborted;
  Parameters:     inJobID - routing job identifier
  Returns:        n/a
  Used:          FinTP/BASE/RE
***********************************************/

BEGIN

   delete from findata.routingjobs where id = inJobID;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while deleting job: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.abortjob(injobid character varying) OWNER TO findata;

--
-- TOC entry 453 (class 1255 OID 201505)
-- Name: archivedata(); Type: FUNCTION; Schema: findata; Owner: postgres
--

CREATE FUNCTION findata.archivedata() RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history: dd.mon.yyyy  --  author  --   description
  Created:        
  Description:    archive business data;
  Parameters:     
  Returns:        n/a
  Used:          FinTP/BASE/DB wa
***********************************************/

BEGIN

  insert into finarch.repstatinvc select * from findata.repstatinvc;
  delete from findata.repstatinvc;

insert into finarch.repstatpymt select * from findata.repstatpymt;
  delete from findata.repstatpymt;

insert into finarch.repstatstmt select * from findata.repstatstmt;
  delete from findata.repstatstmt;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while archiving: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.archivedata() OWNER TO postgres;

--
-- TOC entry 442 (class 1255 OID 2014101)
-- Name: archiveidle(); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.archiveidle() RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:                
  Created:     15.Dec.2020, dd 14525 
  Description: 
  Parameters: 
  Returns:    no tx archived
  Used:       FinTPc/BASE/RE
***********************************************/             

v_yesArchive  integer default 0;
v_firsth      integer;
v_lasth      integer;
v_currenth   integer;
v_archived integer;
rec record;
v_archdate date;
v_period integer;

BEGIN
     
  select substr(value,1,2)::integer,  substr(value,4,2)::integer 
     into v_firsth, v_lasth from fincfg.params where code = 'ARCHI';
  select to_char(now(), 'hh24')::integer into v_currenth;

  if v_firsth > v_lasth then
       if v_currenth >= v_firsth or v_currenth <= v_lasth then
            v_yesArchive := 1;
       end if;
  else
      if v_currenth >= v_firsth and v_currenth <= v_lasth then
            v_yesArchive := 1;
      end if;         
  end if;
  
  v_Archived := 0;   

 if v_yesArchive = 1 then 

  select value::integer into v_period from fincfg.params where code = 'ARCHPP';     
  v_ArchDate := date_trunc('day',current_date);
  v_ArchDate := fincfg.getLastBusinessDay(v_ArchDate, v_period);
   
   for rec in 
    ( select correlationid from findata.repstatpymt where findata.getstatus(correlationid) like 'Completed%' 
                                                          and insertdate <= v_ArchDate
      limit 500
    )                        
    loop
      v_Archived := v_Archived + 1;
      insert into finarch.repstatpymt select * from findata.repstatpymt where correlationid = rec.correlationid;
      insert into finarch.history select * from findata.history where correlationid = rec.correlationid;
      insert into finarch.feedbackagg select * from findata.feedbackagg where correlationid = rec.correlationid;
      insert into finarch.repevents select * from findata.repevents where correlationid = rec.correlationid;
      insert into finarch.routedmessages select * from findata.routedmessages where correlationid = rec.correlationid;
    
      delete from findata.mtcdttrfinitnothrtab where correlationid = rec.correlationid;
      delete from findata.mtcdttrfinitnsalatab where correlationid = rec.correlationid;
      delete from findata.mtcdttrfinitnsupptab  where correlationid = rec.correlationid;
      delete from findata.mtcdttrfinitntaxstab where correlationid = rec.correlationid;
      delete from findata.mtcdttrfinitnvatxtab  where correlationid = rec.correlationid;

      delete from findata.routedmessages where correlationid = rec.correlationid;
      delete from findata.feedbackagg where correlationid = rec.correlationid;
      delete from findata.history   where correlationid = rec.correlationid;
      delete from findata.entryqueue where correlationid = rec.correlationid;
      delete from findata.status where correlationid = rec.correlationid;
    end loop;

  select value::integer into v_period from fincfg.params where code = 'ARCHPI';     
  v_ArchDate := date_trunc('day',current_date);
  v_ArchDate := fincfg.getLastBusinessDay(v_ArchDate, v_period);
   
   for rec in 
    ( select correlationid from findata.repstatinvc where findata.getstatus(correlationid) like 'Completed%' 
                                                          and insertdate <= v_ArchDate 
      limit 500
    )                        
    loop
      v_Archived := v_Archived + 1;
      insert into finarch.repstatinvc select * from findata.repstatinvc where correlationid = rec.correlationid;
      insert into finarch.history select * from findata.history where correlationid = rec.correlationid;
      insert into finarch.feedbackagg select * from findata.feedbackagg where correlationid = rec.correlationid;
      insert into finarch.repevents select * from findata.repevents where correlationid = rec.correlationid;
insert into finarch.routedmessages select * from findata.routedmessages where correlationid = rec.correlationid;
    
    
      delete from findata.mtfininvctab where correlationid = rec.correlationid;

      delete from findata.routedmessages where correlationid = rec.correlationid;
      delete from findata.feedbackagg where correlationid = rec.correlationid;
      delete from findata.history   where correlationid = rec.correlationid;
      delete from findata.entryqueue where correlationid = rec.correlationid;
      delete from findata.status where correlationid = rec.correlationid;
    end loop;

 select value::integer into v_period from fincfg.params where code = 'ARCHPS';     
  v_ArchDate := date_trunc('day',current_date);
  v_ArchDate := fincfg.getLastBusinessDay(v_ArchDate, v_period);
   
   for rec in 
    ( select correlationid from findata.repstatstmt where findata.getstatus(correlationid) like 'Completed%' 
                                                          and insertdate <= v_ArchDate 
      limit 500
    )                        
    loop
      v_Archived := v_Archived + 1;
      insert into finarch.repstatstmt select * from findata.repstatstmt where correlationid = rec.correlationid;
      insert into finarch.history select * from findata.history where correlationid = rec.correlationid;
      insert into finarch.feedbackagg select * from findata.feedbackagg where correlationid = rec.correlationid;
      insert into finarch.repevents select * from findata.repevents where correlationid = rec.correlationid;
insert into finarch.routedmessages select * from findata.routedmessages where correlationid = rec.correlationid;
    
    
      delete from findata.mtbktocstmrdbtcdttab where correlationid = rec.correlationid;

      delete from findata.routedmessages where correlationid = rec.correlationid;
      delete from findata.feedbackagg where correlationid = rec.correlationid;
      delete from findata.history   where correlationid = rec.correlationid;
      delete from findata.entryqueue where correlationid = rec.correlationid;
      delete from findata.status where correlationid = rec.correlationid;
    
    end loop;

  if v_Archived = 0 then
        
  select value::integer into v_period from fincfg.params where code = 'ARCHPE';     
  v_ArchDate := date_trunc('day',current_date);
  v_ArchDate := fincfg.getLastBusinessDay(v_ArchDate, v_period);
   
   for rec in 
    ( select guid from findata.status where insertdate <= v_ArchDate 
      limit 1000
    )                        
    loop
       v_archived = v_archived + 1;
       insert into finarch.repevents select * from findata.repevents where guid = rec.guid;
       delete from findata.status where guid = rec.guid;
    end loop;
	 if v_Archived > 0 then v_Archived := -1; end if; -- related data archived	      
    end if;

   
      
  end if;

  return v_Archived;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while archiving: %', SQLERRM;

END;
$$;


ALTER FUNCTION findata.archiveidle() OWNER TO findata;

--
-- TOC entry 380 (class 1255 OID 62561)
-- Name: batchjob(character varying, integer, character varying, character varying, character varying, text, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.batchjob(injobid character varying, insequence integer, incombatchid character varying, incorrelid character varying, infeedback character varying, inxformitem text, initemamountbdp character varying, initemamountadp character varying, OUT outbatchstatus integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         27.Mar.2013, DenisaN
  Description:     Includes a message in a batch and updates totals
  Parameters:      inJobID  -  routing job identifier          
                   inSequence   -  rule sequence
                   inComBatchID   -  batch identifier
                   inCorrelID  - message correlation identifier        
                   inFeedback   -    feedback code
                   inXformItem  -  transformed (xslt) payload                              
  Returns:         outBatchStatus parameter representing the batch status 
  Used:            FinTP/BASE/RE
***********************************************/

DECLARE

BEGIN

   update findata.batchjobs set status = case when currentmessagecount = messagecount - 1 and  status < 15  then 15
 					                               when status = 0 then 10
     						                       else status                     
					                          end, 
			                    currentmessagecount = currentmessagecount + 1,  
			                    insertdate = now()
   where batchid = inComBatchID returning status into outBatchStatus;   

   -- defer job, if batch not completed/failed
   if outBatchStatus = 10 or outBatchStatus = 15 then
      perform findata.deferbatchjob(inJobID,  inCombatchID, inCorrelID,  inFeedback,  inSequence,  inXformItem); 
   end if;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while creating batch: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.batchjob(injobid character varying, insequence integer, incombatchid character varying, incorrelid character varying, infeedback character varying, inxformitem text, initemamountbdp character varying, initemamountadp character varying, OUT outbatchstatus integer) OWNER TO findata;

--
-- TOC entry 381 (class 1255 OID 62565)
-- Name: commitjob(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.commitjob(injobid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
                   10.Feb.2014, DenisaN - review 
  Created:         17.May.2013,DenisaN - 7164
  Description:     Removes one given routing job. Reason:commited;
  Parameters:      inJobID - routing job identifier
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/


BEGIN

      delete from findata.routingjobs where id = inJobID ;


EXCEPTION
   WHEN OTHERS THEN
         RAISE EXCEPTION 'Unexpected error occured while committing job: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.commitjob(injobid character varying) OWNER TO findata;

--
-- TOC entry 446 (class 1255 OID 2031169)
-- Name: computebsforecast(character varying, integer, integer, integer, integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.computebsforecast(inentity character varying, inrealisebsyear integer, inhistoricalbsyear integer, inforecastbsyear integer, inuserid integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  
  Created:        17.May.2021, dd - 15667
  Description:    Computes BS forecasting data     
  Parameters:                             
  Returns:      
  Used:           FinTPc/Whizzer/UI Cash reporting
***********************************************/

v_realisedbs numeric[];
v_historicalbs numeric[];
v_count integer;

BEGIN

   /* v_realisedbs := array(select omfp2, omfp3, omfp12, omfp16, omfp15, omfp21, omfp30,
                                 omfp40, omfp50, omfp57, omfp60, omfp61, omfp62, omfp63
                          from findata.plloadhistory where year = inrealisebsyear and entity = inentity);
    v_historicalbs := array(select omfp2, omfp3, omfp12, omfp16, omfp15, omfp21, omfp30,
                                 omfp40, omfp50, omfp57, omfp60, omfp61, omfp62, omfp63
                          from findata.plloadhistory where year = inHistoricalBSyear and entity = inentity);
*/

   select array [omfp2, omfp3, omfp12, omfp16, omfp15, omfp21, omfp30,
                 omfp40, omfp50, omfp57, omfp60, omfp61, omfp62, omfp63]
          into v_realisedbs
   from findata.plloadhistory where year = inrealisebsyear and entity = inentity;
   select array [omfp2, omfp3, omfp12, omfp16, omfp15, omfp21, omfp30,
                 omfp40, omfp50, omfp57, omfp60, omfp61, omfp62, omfp63]
          into v_historicalbs
   from findata.plloadhistory where year = inHistoricalBSyear and entity = inentity;

     select count(*) into v_count from findata.bsforecast where forecast = inForecastBSyear and entity = inEntity;
     if v_count > 0 then
    -- update findata.bsforecast set  omfp2 = v_realisedbs[1]
    --  where forecast = inForecastBSyear and entity = inEntity and realisedbs = inrealisebsyear and historicalbs = inHistoricalBSyear;
       update findata.bsforecast set  omfp2f = case when v_historicalbs[1] = 0 then null
                                              else (v_realisedbs[1]/v_historicalbs[1] - 1) * 100
                                           end,
                                      omfp3f = case when v_historicalbs[2] = 0 then null
                                      else (v_realisedbs[2]/v_historicalbs[2] - 1) * 100
                                      end,
                                      omfp12f = case when v_historicalbs[3] = 0 then null
                                      else (v_realisedbs[3]/v_historicalbs[3] - 1) * 100
                                      end,
                                      omfp16f = case when v_historicalbs[4] = 0 then null
                                      else (v_realisedbs[4]/v_historicalbs[4] - 1) * 100
                                      end,
                                      omfp15f = case when v_historicalbs[5] = 0 then null
                                      else (v_realisedbs[5]/v_historicalbs[5] - 1) * 100
                                      end,
                                      omfp21f = case when v_historicalbs[6] = 0 then null
                                      else (v_realisedbs[6]/v_historicalbs[6] - 1) * 100
                                      end,
                                      omfp30f = case when v_historicalbs[7] = 0 then null
                                      else (v_realisedbs[7]/v_historicalbs[7] - 1) * 100
                                      end,
                                      omfp40f = case when v_historicalbs[8] = 0 then null
                                      else (v_realisedbs[8]/v_historicalbs[8] - 1) * 100
                                      end,
                                      omfp50f = case when v_historicalbs[9] = 0 then null
                                      else (v_realisedbs[9]/v_historicalbs[9] - 1) * 100
                                      end,
                                      omfp57f = case when v_historicalbs[10] = 0 then null
                                      else (v_realisedbs[10]/v_historicalbs[10] - 1) * 100
                                      end,
                                      omfp60f = case when v_historicalbs[11] = 0 then null
                                      else (v_realisedbs[11]/v_historicalbs[11] - 1) * 100
                                      end,
                                      omfp61f = case when v_historicalbs[12] = 0 then null
                                      else (v_realisedbs[12]/v_historicalbs[12] - 1) * 100
                                      end,
                                      omfp62f = case when v_historicalbs[13] = 0 then null
                                      else (v_realisedbs[13]/v_historicalbs[13] - 1) * 100
                                      end,
                                      omfp63f = case when v_historicalbs[14] = 0 then null
                                      else (v_realisedbs[14]/v_historicalbs[14] - 1) * 100
                                      end,
                                      realisedbs = inrealisebsyear,
                                      historicalbs = inHistoricalBSyear,
                                      userid = inUserid,
                                      status = 'Up to date'
        where forecast = inForecastBSyear and entity = inEntity;
        
     else
         insert into findata.bsforecast values((select idvalue + 1 from fincfg.idgenlist where tabcolname = 'BSFORECAST_ID'),
                                               inrealisebsyear, inForecastBSyear, inHistoricalBSyear, 
                                               v_realisedbs[1], v_realisedbs[2], v_realisedbs[3], v_realisedbs[4], v_realisedbs[5],
                                               v_realisedbs[6], v_realisedbs[7], v_realisedbs[8], v_realisedbs[9], v_realisedbs[10],
                                               v_realisedbs[11], v_realisedbs[12], v_realisedbs[13], v_realisedbs[14], 
                                               case when v_historicalbs[1] = 0 then null
                                               else (v_realisedbs[1]/v_historicalbs[1] - 1) * 100
                                               end, 
                                                case when v_historicalbs[2] = 0 then null 
                                                else (v_realisedbs[2]/v_historicalbs[2] - 1) * 100
                                                end,
                                               case when v_historicalbs[3] = 0 then null
                                               else (v_realisedbs[3]/v_historicalbs[3] - 1) * 100
                                               end, 
                                               case when v_historicalbs[4] = 0 then null
                                               else (v_realisedbs[4]/v_historicalbs[4] - 1) * 100
                                               end,
                                               case when v_historicalbs[5] = 0 then null
                                               else (v_realisedbs[5]/v_historicalbs[5] - 1) * 100
                                               end, 
                                               case when v_historicalbs[6] = 0 then null 
                                               else (v_realisedbs[6]/v_historicalbs[6] - 1) * 100
                                               end,
                                               case when v_historicalbs[7] = 0 then null 
                                               else (v_realisedbs[7]/v_historicalbs[7] - 1) * 100
                                               end, 
                                               case when v_historicalbs[8] = 0 then null 
                                               else (v_realisedbs[8]/v_historicalbs[8] - 1) * 100
                                               end,
                                               case when v_historicalbs[9] = 0 then null 
                                               else (v_realisedbs[9]/v_historicalbs[9] - 1) * 100
                                               end, 
                                               case when v_historicalbs[10] = 0 then null 
                                               else (v_realisedbs[10]/v_historicalbs[10] - 1) * 100
                                               end,
                                               case when v_historicalbs[11] = 0 then null 
                                               else (v_realisedbs[11]/v_historicalbs[11] - 1) * 100
                                               end, 
                                                case when v_historicalbs[12] = 0 then null
                                                else (v_realisedbs[12]/v_historicalbs[12] - 1) * 100
                                                end,
                                                case when v_historicalbs[13] = 0 then null
                                                else (v_realisedbs[13]/v_historicalbs[13] - 1) * 100
                                                end, 
                                                case when v_historicalbs[14] = 0 then null
                                                else (v_realisedbs[14]/v_historicalbs[14] - 1) * 100
                                                end,
                                               inentity, inuserid, 'Up to date');
     update fincfg.idgenlist set idvalue = idvalue+1  where tabcolname = 'BSFORECAST_ID';
     
     end if;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while forecasting. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.computebsforecast(inentity character varying, inrealisebsyear integer, inhistoricalbsyear integer, inforecastbsyear integer, inuserid integer) OWNER TO findata;

--
-- TOC entry 382 (class 1255 OID 62566)
-- Name: createbatchrequest(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.createbatchrequest(inqueuename character varying, inmsgtype character varying, ingroupkey character varying, intimekey character varying, infield1val character varying, infield2val character varying, infield3val character varying, infield4val character varying, infield5val character varying, inuserid integer) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history: 
09.Dec.2020, dd 14522
05.Jun.2018, DanielC 12857
                  06.Jan.2016, DenisaN 9496                       
  Created:        02.Apr.2014, DenisaN 7488
  Description:   Initiates the batching mechanism; gathers messages in given group and assignes routing jobs.  
  Parameters:    inqueuename   - queue name
                 inmsgtype     - message type [for messages in group]
                 ingroupkey    - message group key [unique hash]
                 intimekey     - message group time reference
                 infield1val   - kword1 group value 
                 infield2val   - kword2 group value
                 infield3val   - kword3 group value
                 infield4val   - kword4 group value
                 infield5val   - kword5 group value
                 inusername    - user name 
  Returns:       cursor
  Used:          FinTP/BASE/UI
***********************************************/             

v_groupkey        varchar(100);
v_filterfields    varchar(1000);
v_qreportingview  varchar(35);
v_maxbatchcnt     integer;
v_priority        integer;
v_batchuid        varchar(30);
v_batchuidold     varchar(30) default 'X';
v_guid            varchar(30);
v_func            varchar(1000);
v_msgs            refcursor;
v_host varchar(100);
    
BEGIN

 select inet_server_addr() into v_host;
 v_host := substr(v_host,1 , strpos(v_host, '/') - 1);

  --get specific storage
  select reportingstorage into v_qreportingview from fincfg.messagetypes where messagetype = inmsgtype;   
      
  --get specific filter fields
  select case when routingkeyword1 is not null then ' and '||routingkeyword1||' = '''||infield1val||'''' else ' ' end ||
         case when routingkeyword2 is not null then ' and '||routingkeyword2||' = '''||infield2val||'''' else ' ' end ||
         case when routingkeyword3 is not null then ' and '||routingkeyword3||' = '''||infield3val||'''' else ' ' end ||
         case when routingkeyword4 is not null then ' and '||routingkeyword4||' = '''||infield4val||'''' else ' ' end ||
         case when routingkeyword5 is not null then ' and '||routingkeyword5||' = '''||infield5val||'''' else ' ' end         
  into v_filterfields
  from fincfg.queuemessagegroups where messagetype = inmsgtype;

  --recompute group key
  execute 
 ' select md5(string_agg(id,'''' order by id)) '||
 ' from findata.'||v_qreportingview||' where queuename = $1 '||
         ' and insertdate <= $2'||v_filterfields
  into v_groupkey
  using inqueuename, to_timestamp(intimekey, 'ddmmyyyyhh24:mi:ss');
   
if v_groupkey = ingroupkey then
         
     --max msgs per batch
     select maxtrxonbatch, priority into v_maxbatchcnt, v_priority from fincfg.queues where name = inqueuename;
     
  --insert Batch routing jobs
  open v_msgs for execute
     ' select id, '||      
       ' ''F=Route, F=Unhold,''|| '||
       ' ''P=GroupOrder(''|| ( row_number() over ( partition by ceil(rn::numeric/$1::numeric ) order by rn) ) ||''), ''|| '||
       ' ''P=GroupCount('' || ( count( rn ) over ( partition by ceil(rn::numeric/$1::numeric) ) )  || ''), ''|| '||
       ' ''P=BatchID('' || trim( max( id ) over ( partition by ceil(rn::numeric/$1::numeric) ) ) || ''), ''|| '||
       ' ''P=BatchSum('' || to_char(sum(  to_number(CASE 
                       WHEN (rtrim((amount)::text) IS NULL) THEN ''0,00''::text 
                       WHEN (rtrim((amount)::text) = ''''::text) THEN ''0,00''::text 
                       WHEN (rtrim((amount)::text) = '',''::text) THEN ''0,00''::text 
                       ELSE replace(rtrim((amount)::text), '',''::text, ''.''::text) END, ''FM99999999999999999D99''::text))  
                      over ( partition by ceil(rn::numeric/$1::numeric) ), ''FM999999999999999990D99'')||''), ''|| '||
       case when inmsgtype = 'MFILoanDisb' then
       ' ''P=BatchRef('' ||''ENCOT '' || to_char(current_date, ''dd-mm-yyyy'') ||'' AU ''|| '')'' func, '
            when inmsgtype = 'MFILoanRepay' then
       ' ''P=BatchRef('' ||''ENCOT '' || to_char(current_date, ''dd-mm-yyyy'') ||'' FU ''|| '')'' func, '
            when inmsgtype in ('CstmrCdtTrfInitnSala', 'CstmrCdtTrfInitnSupp', 'CstmrCdtTrfInitnTaxs', 'CstmrCdtTrfInitnVatx', 'CstmrCdtTrfInitnOthr') then
       ' ''P=BatchRef('' || to_char(current_date, ''YYMMDD'') || '')'' func, '
           else
       ' ''P=BatchRef('' || substr( receiver, 1, 4 ) || to_char(current_date, ''yyyymmdd'') || '')'' func, '
       end||                            
       ' trim( max (id) over ( partition by ceil(rn::numeric/$1::numeric) ) ) batchuid '||                 
    ' from '||
      '( select id, receiver, amount, row_number() over () rn, count(receiver) over (partition by receiver) tm '||
       ' from findata.'||v_qreportingview|| ' where queuename = $2 and insertdate <= $3 '||v_filterfields||
     ' ) tmp '  
  using  v_maxbatchcnt, inQueueName, to_timestamp(intimekey, 'ddmmyyyyhh24:mi:ss');       
  loop          
     fetch v_msgs into v_guid, v_func, v_batchuid;
     exit when not found;
                  
     insert into findata.routingjobs(id, status, priority, backout, routingpoint, function, userid)  
                              values(v_guid, 0, v_priority, 0, inQueueName, v_func, inuserid);
             
     --register batch request / batchuid - group key correlation                   
     if (v_batchuidold != v_batchuid and v_batchuid is not null) then
         
         insert into findata.batchrequests(groupkey, batchuid, userid) 
                                    values(v_groupkey, v_batchuid, inuserid);  
        
        perform findata.insertevent(to_char(current_timestamp, 'mmddhhmissms'), -1, '00000000-00000000-00000000', '', 'Info',
                              v_host, to_char(current_timestamp, 'YYYY-MM-DD-HH24.MI.SS'), 'Transactions authorized for further routing in batch', 'Transaction.Operate', v_batchuid, '', inuserid, '');
   
         v_batchuidold := v_batchuid;
     end if;                      
  end loop;
       
  close v_msgs;  

   
    
else 
    raise exception 'data_changed';
  
end if;
 

EXCEPTION
WHEN OTHERS THEN
      perform findata.insertevent(to_char(current_timestamp, 'mmddhhmissms'), -1, '00000000-00000000-00000000', '', 'Warning',
                              v_host, to_char(current_timestamp, 'YYYY-MM-DD-HH24.MI.SS'), 'Error while Transactions authorized for further routing in batch', 'Transaction.Operate', v_batchuid, '', inuserid, '');
    
  RAISE EXCEPTION 'Unexpected error occured while creating batch: %', SQLERRM;
 

END;
$_$;


ALTER FUNCTION findata.createbatchrequest(inqueuename character varying, inmsgtype character varying, ingroupkey character varying, intimekey character varying, infield1val character varying, infield2val character varying, infield3val character varying, infield4val character varying, infield5val character varying, inuserid integer) OWNER TO findata;

--
-- TOC entry 383 (class 1255 OID 62569)
-- Name: createroutingjob(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.createroutingjob(inqueuename character varying, inaction character varying, inreason character varying, inactiondetails character varying, inmsgtype character varying, inmsgid character varying, ingroupkey character varying, intimekey character varying, infield1val character varying, infield2val character varying, infield3val character varying, infield4val character varying, infield5val character varying, inuserid integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE


/************************************************
  Change history: dd.mon.yyyy  --  author  --   description   
09.Jun.2021, dd 15776
09.Dec.2020, dd 14522                  
10.Jan.2020, dd 14477                   
  Created:        26.Jul.2018, dd 12964
  Description:    Create routing jobs for given user actions;  
  Parameters:    inqueuename   - queue name
                 inmsgtype     - message type 
                 inactioan     - internal action name
                 inmsgid       - message identifier [for single transaction actions]
                 ingroupkey    - message group key [unique hash]
                 intimekey     - message group time reference
                 infield1val   - kword1 group value 
                 infield2val   - kword2 group value
                 infield3val   - kword3 group value
                 infield4val   - kword4 group value
                 infield5val   - kword5 group value
                 inusername    - user name 
  Returns:       cursor
  Used:          FinTP/BASE/UI
***********************************************/             

v_priority    integer;
v_function    varchar(255);
v_qname varchar(50);
v_correlationid varchar(50);
v_message varchar(300);
v_additionalinfo varchar(300);
v_host varchar(100);
 
BEGIN

 select inet_server_addr() into v_host;
 v_host := substr(v_host,1 , strpos(v_host, '/') - 1);

 if inaction = 'Batch' then
    perform findata.createbatchrequest(inqueuename, inmsgtype, ingroupkey, intimekey, 
                               infield1val, infield2val, infield3val, infield4val, infield5val, inuserid);

 elsif inaction in ('Route', 'Reject', 'Suspend', 'Investigate', 'Edit', 'Complete', 'CancelEdit', 'MoveTo') then
  
    select correlationid into v_correlationid from findata.entryqueue where id = inmsgid;

        if inaction = 'Route' then
                                      v_priority :=  80;
                                      v_function := 'F=Route, F=Unhold';
                                      v_message := 'Transaction ['||v_correlationid||'] authorized for further routing';
                                      v_additionalinfo := 'Source queue: '||inqueuename;
                                                  
         elsif inaction = 'Reject' and inreason = 'duplicate' then
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Complete, P=Feedback(PDM00)';
                                      v_message := 'Transaction ['||v_correlationid||'] authorized for rejecting'; 
                                      v_additionalinfo := 'Source queue: '||inqueuename||'; Reason: '||inreason||'Details: '||coalesce(inactiondetails, ' ');
                                        
         elsif inaction = 'Reject' and inreason = 'others' then
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Complete, P=Feedback(FTP09)'; 
                                      v_message := 'Transaction ['||v_correlationid||'] authorized for rejecting'; 
                                      v_additionalinfo := 'Source queue: '||inqueuename||'; Reason: '||inreason||'Details: '||coalesce(inactiondetails, ' ');
                                        
         elsif inaction = 'Suspend' and inreason = 'duplicate' then
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Complete, P=Feedback(PDM10), P=NoReply(true)'; 
                                       v_message := 'Transaction ['||v_correlationid||'] authorized for suspending'; 
                                      v_additionalinfo := 'Source queue: '||inqueuename||'; Reason: '||inreason||'Details: '||coalesce(inactiondetails, ' ');

         elsif inaction = 'Suspend' and inreason = 'others' then
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Complete, P=Feedback(FTP19), P=NoReply(true)'; 
                                      v_message := 'Transaction ['||v_correlationid||'] authorized for suspending'; 
                                      v_additionalinfo := 'Source queue: '||inqueuename||'; Reason: '||inreason||'Details: '||coalesce(inactiondetails, ' ');

        elsif inaction = 'MoveTo' then
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Dispose, P=Destination('||inReason||')'; 
                                      v_message := 'Transaction ['||v_correlationid||'] authorized for moving to destination queue'; 
                                      v_additionalinfo := 'Source queue: '||inqueuename||'; Destination queue: '||inreason;


         elsif inaction = 'Complete' then --not user action;used for edit
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Complete, P=NoReply(true)'; 

           
         elsif inaction = 'Investigate' and inmsgtype in ('CstmrCdtTrfInitnVatx', 'CstmrCdtTrfInitnTaxs', 
                                                      'CstmrCdtTrfInitnSupp', 'CstmrCdtTrfInitnSala', 'CstmrCdtTrfInitnOthr') then
                    select name into v_qname from fincfg.queues where messagetypesbusinessarea = 'Payments';
                    v_priority :=  70;
                    v_function := 'F=Unhold, F=Dispose, P=Destination('||v_qname||')'; 
                    v_message := 'Transaction ['||v_correlationid||'] authorized for investigation'; 
                    v_additionalinfo := 'Source queue: '||inqueuename||'; Reason: '||inactiondetails;
          
         elsif inaction = 'CancelEdit' and inmsgtype in ('CstmrCdtTrfInitnVatx', 'CstmrCdtTrfInitnTaxs', 
                                                      'CstmrCdtTrfInitnSupp', 'CstmrCdtTrfInitnSala', 'CstmrCdtTrfInitnOthr') then
                    select name into v_qname from fincfg.queues where messagetypesbusinessarea = 'Payments';
                    v_priority :=  70;
                    v_function := 'F=Unhold, F=Dispose, P=Destination('||v_qname||')'; 
                    v_message := 'Transaction ['||v_correlationid||'] canceled for editing'; 
                    v_additionalinfo := 'Moved back for investigations';
      
          elsif inaction = 'Edit' and inmsgtype in ('CstmrCdtTrfInitnVatx', 'CstmrCdtTrfInitnTaxs', 
                                                    'CstmrCdtTrfInitnSupp', 'CstmrCdtTrfInitnSala', 'CstmrCdtTrfInitnOthr') then                  
                    v_priority :=  70;
                    v_function := 'F=Unhold, F=Dispose, P=Destination(Edit)'; 
                    v_message := 'Transaction ['||v_correlationid||'] authorized for editing';                   

         else raise exception 'bad_req_excp';
         end if;

    begin  
       insert into findata.routingjobs(id, status, backout, priority, routingpoint, function, userid, operationdetails)
                        values(inmsgid, 0, 0, v_priority, inqueuename, v_function, inuserid, inactiondetails);
      exception when unique_violation then 
       raise exception 'already_exists_excp';
     end;

  
  --register event
  if v_message is not null then
  perform findata.insertevent(to_char(current_timestamp, 'mmddhhmissms'), -1, v_correlationid, '', 'Info',
                              v_host, to_char(current_timestamp, 'YYYY-MM-DD-HH24.MI.SS'), v_message, 'Transaction.Operate', v_additionalinfo, '', inuserid, '');
  end if;

 else
     raise exception 'bad_req_excp';

 end if;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while creating routing job: %', SQLERRM;
    perform findata.insertevent(to_char(current_timestamp, 'mmddhhmissms'), -1, v_correlationid, '', 'Warning',
                              v_host, to_char(current_timestamp, 'YYYY-MM-DD-HH24.MI.SS'), 'Error while '||v_message, 'Transaction.Operate', v_additionalinfo, '', inuserid, '');

END;
$$;


ALTER FUNCTION findata.createroutingjob(inqueuename character varying, inaction character varying, inreason character varying, inactiondetails character varying, inmsgtype character varying, inmsgid character varying, ingroupkey character varying, intimekey character varying, infield1val character varying, infield2val character varying, infield3val character varying, infield4val character varying, infield5val character varying, inuserid integer) OWNER TO findata;

--
-- TOC entry 444 (class 1255 OID 2031165)
-- Name: createroutingjob(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, character varying[]); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.createroutingjob(inqueuename character varying, inaction character varying, inreason character varying, inactiondetails character varying, inmsgtype character varying, inmsgid character varying, ingroupkey character varying, intimekey character varying, infield1val character varying, infield2val character varying, infield3val character varying, infield4val character varying, infield5val character varying, inuserid integer, intxids character varying[]) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE


/************************************************
  Change history: dd.mon.yyyy  --  author  --   description 
07.Sep.2021, dd 1590  
09.Jun.2021, dd 15776
09.Dec.2020, dd 14522                  
10.Jan.2020, dd 14477                   
  Created:        26.Jul.2018, dd 12964
  Description:    Create routing jobs for given user actions;  
  Parameters:    inqueuename   - queue name
                 inmsgtype     - message type 
                 inactioan     - internal action name
                 inmsgid       - message identifier [for single transaction actions]
                 ingroupkey    - message group key [unique hash]
                 intimekey     - message group time reference
                 infield1val   - kword1 group value 
                 infield2val   - kword2 group value
                 infield3val   - kword3 group value
                 infield4val   - kword4 group value
                 infield5val   - kword5 group value
                 inusername    - user name 
  Returns:       cursor
  Used:          FinTP/BASE/UI
***********************************************/             

v_priority    integer;
v_function    varchar(255);
v_qname varchar(50);
v_correlationid varchar(50);
v_message varchar(300);
v_additionalinfo varchar(300);
v_host varchar(100);
 
BEGIN

 select inet_server_addr() into v_host;
 v_host := substr(v_host,1 , strpos(v_host, '/') - 1);

 if inaction = 'Batch' then
    perform findata.createbatchrequest(inqueuename, inmsgtype, ingroupkey, intimekey, 
                               infield1val, infield2val, infield3val, infield4val, infield5val, inuserid,  intxids);

 elsif inaction in ('Route', 'Reject', 'Suspend', 'Investigate', 'Edit', 'Complete', 'CancelEdit', 'MoveTo') then
  
    select correlationid into v_correlationid from findata.entryqueue where id = inmsgid;

        if inaction = 'Route' then
                                      v_priority :=  80;
                                      v_function := 'F=Route, F=Unhold';
                                      v_message := 'Transaction ['||v_correlationid||'] authorized for further routing';
                                      v_additionalinfo := 'Source queue: '||inqueuename;
                                                  
         elsif inaction = 'Reject' and inreason = 'duplicate' then
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Complete, P=Feedback(PDM00), P=NoReply(false)';
                                      v_message := 'Transaction ['||v_correlationid||'] authorized for rejecting'; 
                                      v_additionalinfo := 'Source queue: '||inqueuename||'; Reason: '||inreason||'Details: '||coalesce(inactiondetails, ' ');
                                        
         elsif inaction = 'Reject' and inreason = 'others' then
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Complete, P=Feedback(FTP09), P=NoReply(false)'; 
                                      v_message := 'Transaction ['||v_correlationid||'] authorized for rejecting'; 
                                      v_additionalinfo := 'Source queue: '||inqueuename||'; Reason: '||inreason||'Details: '||coalesce(inactiondetails, ' ');
                                        
         elsif inaction = 'Suspend' and inreason = 'duplicate' then
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Complete, P=Feedback(PDM10), P=NoReply(true)'; 
                                       v_message := 'Transaction ['||v_correlationid||'] authorized for suspending'; 
                                      v_additionalinfo := 'Source queue: '||inqueuename||'; Reason: '||inreason||'Details: '||coalesce(inactiondetails, ' ');

         elsif inaction = 'Suspend' and inreason = 'others' then
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Complete, P=Feedback(FTP19), P=NoReply(true)'; 
                                      v_message := 'Transaction ['||v_correlationid||'] authorized for suspending'; 
                                      v_additionalinfo := 'Source queue: '||inqueuename||'; Reason: '||inreason||'Details: '||coalesce(inactiondetails, ' ');

        elsif inaction = 'MoveTo' then
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Dispose, P=Destination('||inReason||')'; 
                                      v_message := 'Transaction ['||v_correlationid||'] authorized for moving to destination queue'; 
                                      v_additionalinfo := 'Source queue: '||inqueuename||'; Destination queue: '||inreason;


         elsif inaction = 'Complete' then --not user action;used for edit
                                      v_priority :=  70;
                                      v_function := 'F=Unhold, F=Complete, P=NoReply(true)'; 

           
         elsif inaction = 'Investigate' and inmsgtype in ('CstmrCdtTrfInitnVatx', 'CstmrCdtTrfInitnTaxs', 
                                                      'CstmrCdtTrfInitnSupp', 'CstmrCdtTrfInitnSala', 'CstmrCdtTrfInitnOthr') then
                    select name into v_qname from fincfg.queues where messagetypesbusinessarea = 'Payments';
                    v_priority :=  70;
                    v_function := 'F=Unhold, F=Dispose, P=Destination('||v_qname||')'; 
                    v_message := 'Transaction ['||v_correlationid||'] authorized for investigation'; 
                    v_additionalinfo := 'Source queue: '||inqueuename||'; Reason: '||inactiondetails;
          
         elsif inaction = 'CancelEdit' and inmsgtype in ('CstmrCdtTrfInitnVatx', 'CstmrCdtTrfInitnTaxs', 
                                                      'CstmrCdtTrfInitnSupp', 'CstmrCdtTrfInitnSala', 'CstmrCdtTrfInitnOthr') then
                    select name into v_qname from fincfg.queues where messagetypesbusinessarea = 'Payments';
                    v_priority :=  70;
                    v_function := 'F=Unhold, F=Dispose, P=Destination('||v_qname||')'; 
                    v_message := 'Transaction ['||v_correlationid||'] canceled for editing'; 
                    v_additionalinfo := 'Moved back for investigations';
      
          elsif inaction = 'Edit' and inmsgtype in ('CstmrCdtTrfInitnVatx', 'CstmrCdtTrfInitnTaxs', 
                                                    'CstmrCdtTrfInitnSupp', 'CstmrCdtTrfInitnSala', 'CstmrCdtTrfInitnOthr') then                  
                    v_priority :=  70;
                    v_function := 'F=Unhold, F=Dispose, P=Destination(Edit)'; 
                    v_message := 'Transaction ['||v_correlationid||'] authorized for editing';                   

         else raise exception 'bad_req_excp';
         end if;

    begin  
       insert into findata.routingjobs(id, status, backout, priority, routingpoint, function, userid, operationdetails)
                        values(inmsgid, 0, 0, v_priority, inqueuename, v_function, inuserid, inactiondetails);
      exception when unique_violation then 
       raise exception 'already_exists_excp';
     end;

  
  --register event
  if v_message is not null then
  perform findata.insertevent(to_char(current_timestamp, 'mmddhhmissms'), -1, v_correlationid, '', 'Info',
                              v_host, to_char(current_timestamp, 'YYYY-MM-DD-HH24.MI.SS'), v_message, 'Transaction.Operate', v_additionalinfo, '', inuserid, '');
  end if;

 else
     raise exception 'bad_req_excp';

 end if;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while creating routing job: %', SQLERRM;
    perform findata.insertevent(to_char(current_timestamp, 'mmddhhmissms'), -1, v_correlationid, '', 'Warning',
                              v_host, to_char(current_timestamp, 'YYYY-MM-DD-HH24.MI.SS'), 'Error while '||v_message, 'Transaction.Operate', v_additionalinfo, '', inuserid, '');

END;
$$;


ALTER FUNCTION findata.createroutingjob(inqueuename character varying, inaction character varying, inreason character varying, inactiondetails character varying, inmsgtype character varying, inmsgid character varying, ingroupkey character varying, intimekey character varying, infield1val character varying, infield2val character varying, infield3val character varying, infield4val character varying, infield5val character varying, inuserid integer, intxids character varying[]) OWNER TO findata;

--
-- TOC entry 384 (class 1255 OID 62570)
-- Name: deferbatchjob(character varying, character varying, character varying, character varying, integer, text); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.deferbatchjob(injobid character varying, inbatchid character varying, incorrelid character varying, infeedback character varying, insequence integer, inxformitem text) RETURNS void
    LANGUAGE plpgsql
    AS $$
/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         27.Mar.2013, DenisaN
  Description:     Deffers one given batch job;
  Parameters:      inJobID - routing job identifier
                   inBatchID - batch identifier - computed by RE
                   inCorrelID  -  correlation identifier
                   inFeedback - feedback code
                   inSequence - routing sequence
                   inXformItem - 
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/

DECLARE


BEGIN

  insert into findata.tempbatchjobs (id, sequence, batchid, correlationId, feedback, xformitem) 
                            values  (inJobID, inSequence, inBatchID, inCorrelID, inFeedback, inXformItem);

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while deffering job. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.deferbatchjob(injobid character varying, inbatchid character varying, incorrelid character varying, infeedback character varying, insequence integer, inxformitem text) OWNER TO findata;

--
-- TOC entry 451 (class 1255 OID 184102)
-- Name: deferjob(character varying, integer, character varying, character varying, integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.deferjob(injobid character varying, inqueueid integer, inroutingpoint character varying, inroutingfunction character varying, inroutinguser integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         17.May.2013, DenisaN - 7164
  Description:     Defers one given routing job;
  Parameters:      inJobID - routing job identifier
                   inQueueID - queue identifier
                   inRoutingPoint  - queue name   
                   inRoutingFunction - routing function
                   inRoutingUser - user identifier
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/

BEGIN

  update routingjobs  set status    = inQueueID,  routingpoint = inRoutingPoint,  function  = inRoutingFunction, userid   = inRoutingUser
                where routingjobs.id = inJobID;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while deffering job: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.deferjob(injobid character varying, inqueueid integer, inroutingpoint character varying, inroutingfunction character varying, inroutinguser integer) OWNER TO findata;

--
-- TOC entry 385 (class 1255 OID 62572)
-- Name: deletemessagefromqueue(character varying, character varying, integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.deletemessagefromqueue(inguid character varying, inqueuename character varying, inisreply integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:      dd.mon.yyyy  --  author  --   description
                       20.Mar.2014, DenisaN 8303
  Created:             09.Aug.2013, LucianP 7163
  Description:         Removes messages from queue [message has been routed to the end point] or
                                   removes reply messages from queue.  
  Parameters:          inGuid - message identifier
                       inQueueName -  destination queue name [null]
                       inIsReply - 1/0 values whether the message is a reply                                   
  Returns:             n/a
  Used:                FinTP/BASE/RE
***********************************************/


BEGIN
    if inIsReply = 0 then
        
        update findata.routedmessages set currentqueue = null where correlationid = (select correlationid from entryqueue where id = inGuid);
        delete from findata.entryqueue where id = inGuid;
        
    elsif inIsReply = 1 then    
        delete from findata.entryqueue where id = inGuid;             
    end if;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while moving message. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.deletemessagefromqueue(inguid character varying, inqueuename character varying, inisreply integer) OWNER TO findata;

--
-- TOC entry 363 (class 1255 OID 183196)
-- Name: enrichmessagedata(character varying, character varying, character varying, character varying, character varying, character varying[], character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.enrichmessagedata(inmsgtype character varying, insenderapp character varying, inreceiverapp character varying, inguid character varying, incorrelid character varying, inkwnames character varying[], inentity character varying) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/                                                                                                        
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
                   28.Oct.2021, dd - 16172
  Created:         20.Jan.2020, luisa
  Description:     Update every routed message into common table and specific tables.
  Parameters:      inMsgType       - message type to be updated
		           inCorrelID      - correlation identifier  
		           inKWNames       - message keywords [see cfg.routingkeywordmapps] followed by their values
  Returns:        
  Used:            FinTP/BASE/RE
***********************************************/


v_ReferenceIdx     integer default 0;
v_SenderIdx        integer default 0;
v_ReceiverIdx      integer default 0;
v_AmountIdx        integer default 0;
v_tablename        varchar(35);
v_updatefields     varchar(2000) default '(';
v_updatevalues     varchar(2000) default '(';
v_half             integer;
--v_kwvalues         varchar[];
v_dateformat       varchar(6);
v_ioidentifier     varchar(1);

BEGIN

     v_half:= array_length(inKWNames,1)/2;
     
     for i in 1..v_half loop
            
            case  
                     --extract message common info  and ammount
                      when inKWNames[i] = 'Reference' then v_ReferenceIdx:=i;
                      when inKWNames[i] = 'Sender' then v_SenderIdx:=i;
                      when inKWNames[i] = 'Receiver' then v_ReceiverIdx:=i;
                      --when inKWNames[i] = 'Amount' then v_AmountIdx:=i;
                      
            else 
                      --extract message specific info
                      v_updatefields := v_updatefields||inKWNames[i];

                     if inKWNames[i + v_half] is null then 
					    v_updatevalues := v_updatevalues||''''||'null'||'''';
					    
					  --standard date format
					 elsif lower(inKWNames[i]) like '%date' then                          
                        select findata.getbusinessdateformat(inKWNames[i + v_half]) into v_dateformat;  
                        v_updatevalues := v_updatevalues||''''||v_dateformat||'''';
                          
                     else
       				    v_updatevalues := v_updatevalues||' E'||''''||replace(inKWNames[i + v_half],'''','\''')||'''';                    
       				    
                     end if;
                                 
                     v_updatefields := v_updatefields||',';
                     v_updatevalues := v_updatevalues||','; 
            end case; 
     end loop;  

    --retrieve specific message table storage                                           
    select distinct storage into  v_tablename from fincfg.messagetypes where messagetype =  inMsgType; 
  
   --update message info into storage tables    
    update findata.routedmessages SET (/*currentqueue*/ messagetype, sender, receiver, reference, requestorservice, responderservice, entity) 
                                   = (/*fincfg.getqueueid(insenderapp||'Queue')*/ inMsgType, inKWNames[v_SenderIdx+v_half], inKWNames[v_ReceiverIdx+v_half], inKWNames[v_ReferenceIdx+v_half], inSenderApp, inReceiverApp, inentity)
        where correlationid = inCorrelID;    
							   
							                                                                                             
 execute 'update findata.'||v_tablename||' SET '||v_updatefields||' correlationid) = '||v_updatevalues||' $1 ) where correlationid = $1' using inCorrelID;
	

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while updating message: %', SQLERRM;
       
END;
$_$;


ALTER FUNCTION findata.enrichmessagedata(inmsgtype character varying, insenderapp character varying, inreceiverapp character varying, inguid character varying, incorrelid character varying, inkwnames character varying[], inentity character varying) OWNER TO findata;

--
-- TOC entry 459 (class 1255 OID 2022609)
-- Name: getbalancesheetdynamic(integer, integer, integer[], character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getbalancesheetdynamic(inyearmin integer, inyearmax integer, inindicatorsid integer[], inentity character varying) RETURNS SETOF refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         23.Feb.2021, LuisaP 7496
  Description:     Gets a routing rule by its identifier
  Parameters:      inyearmin - range strat year
				   inyearmax - range end year
				   inindicatorsnames - name for one or more indicators
  Returns:         outcursorkpis  representing data report generated for Kpis
				   outcursorbsandpl  representing data report generated for P&L and Balance Sheet
  Used:            FinTP/BASE/RE
***********************************************/
v_namevalues         character varying[];
v_reportingcategory  character varying[];
v_inindicatorsnames character varying[];
v_lengtharray        integer;
v_selectedfieldsbs     varchar(2000)default '';
v_selectedfieldspl     varchar(2000)default '';
v_selectedfieldskpis     varchar(2000)default '';
v_stmt1				     varchar(2000)default '';
v_stmt2				     varchar(2000)default '';
outcursorkpis REFCURSOR;
		
		
BEGIN

	v_namevalues := ARRAY(select name from fincfg.configbsandplrepo where id = ANY(inindicatorsid));
	v_reportingcategory := ARRAY(select reportingcategory from fincfg.configbsandplrepo where id = ANY(inindicatorsid));
	v_inindicatorsnames := ARRAY(select name from fincfg.configbsandplrepo where id = ANY(inindicatorsid));
	
	
	v_lengtharray:= array_length(inindicatorsid,1);
	outcursorkpis := 'outcursorkpis';
	

     for i in 1..v_lengtharray loop
	 
	 case  

		when v_reportingcategory[i] = 'KPIs' then v_selectedfieldskpis := v_selectedfieldskpis||'kpis.'||v_namevalues[i]||', '''||inindicatorsid[i]||''' as id_'||v_namevalues[i];
					v_selectedfieldskpis := v_selectedfieldskpis||',';

           end case; 
			
			
		end loop; 
	
	open outcursorkpis for execute 
	'select '||v_selectedfieldskpis||' kpis.year, ROW_NUMBER() OVER (ORDER BY kpis.year) AS id from (select bs.year,
	case when pl.omfp21 is not null and pl.omfp1 is not null then pl.omfp21/pl.omfp1*100 else null end as emplcostsinturnover,
			case when pl.omfp67 is not null and pl.omfp1 is not null then pl.omfp67/pl.omfp1*100 else null end  as  profitrate,
			case when bs.totalcapstr is not null and bs.totalact is not null then bs.totalcapstr/bs.totalact*100 else null end as debitratio,
			case when bs.omfp11 is not null and bs.omfp15 is not null then bs.omfp11/bs.omfp15 else null end as currentratio,
			case when pl.omfp67 is not null and bs.omfp48 is not null then pl.omfp67/bs.omfp48*100 else null end as roe,
			case when pl.omfp1 is not null and bs.totalact is not null then pl.omfp1/bs.totalact else null end as assetrurnoverratio
	from findata.repbalancesheet bs full join findata.repprofitandloss pl on bs.year = pl.year and bs.entity = pl.entity
	where (bs.year between '||inyearmin||' and '||inyearmax||' and bs.entity ='''||inentity||''') OR (pl.year between '||inyearmin||' and '||inyearmax||' and pl.entity = '''||inentity||''')) kpis';	
	 RETURN NEXT outcursorkpis;
	

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while retrieving routing rule: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getbalancesheetdynamic(inyearmin integer, inyearmax integer, inindicatorsid integer[], inentity character varying) OWNER TO findata;

--
-- TOC entry 441 (class 1255 OID 62575)
-- Name: getbatchjobs(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getbatchjobs(OUT outretcursor refcursor, incombatchid character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
                                                                                                    
/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/                                                                                                        
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         02.Dec.2013, DenisaN
  Description:     Gathers info for one batch job not yet completed.
  Parameters:      inCombatchID - computed batch identifier
  Returns:         outRetCursor parameter representing cursor result set
  Used:            FinTP/BASE/RE
***********************************************/

BEGIN

 open outRetCursor for
    select tbj.id id, tbj.sequence, tbj.correlationid, tbj.feedback,
                 tbj.xformitem, bj.routingpoint,  bj.messagecount,   bj.amount
    from findata.tempbatchjobs tbj 
    left  join findata.batchjobs bj on tbj.batchid = bj.batchid 
    where tbj.batchid = inCombatchID;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering job info. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getbatchjobs(OUT outretcursor refcursor, incombatchid character varying) OWNER TO findata;

--
-- TOC entry 387 (class 1255 OID 62576)
-- Name: getbatchstatus(character varying, integer, integer, character varying, integer, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getbatchstatus(inbatchid character varying, inuserid integer, inbatchcount integer, inbatchamount character varying, inserviceid integer, inroutingpoint character varying, inbatchuid character varying, OUT outbatchstatus integer, OUT outcombatchid character varying) RETURNS record
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:   dd.mon.yyyy  --  author  --   description
                    28.Jan.2014, DenisaN 
  Created:          20.Aug.2013, LucianP
  Description:      Creates a batch job, if none existing with the given values   
  Parameters:       inBatchID   - batch identifier
                    inUserID   - user identifier
                    inBatchCount  - no of messages in batch
                    inBatchAmount  - batch total amount
                    inServiceID   - service identifier
                    inRoutingPoint   - queue name
                    inBatchUID   - 
  Returns:          outBatchStatus,  outComBatchID 
                    parameters representing batch identifier and status
  Used:             FinTP/BASE/RE
***********************************************/        

v_comBatchId  character varying(35);
v_serviceSeq  integer;

BEGIN

  -- this select may fail if the batch was not created
  select into outBatchStatus, outComBatchID  
  status, batchid 
  from findata.batchjobs where initialbatchid = inBatchID and userid = inUserID
                           and messagecount = inBatchCount and amount = inBatchAmount
                           and batchuid = inBatchUID ;

  if outBatchStatus is null and outComBatchID is null then 

    --get batchid sequence - service specific
    select findata.getnextservicesequence(inServiceID) into v_serviceSeq; 
    v_comBatchId := inBatchID ||substr(to_char(v_serviceSeq,'0000'),2);

--    ENCOT
--    v_comBatchId := inBatchID ||substr(to_char(v_serviceSeq,'00'),2);

	outBatchStatus := 0; 
  
      --create batching job
	 insert into findata.batchjobs (initialbatchid, userid, messagecount, amount, batchid, currentmessagecount, status,
                                    insertdate, finalamount, routingpoint, batchtype, batchuid)
                                 values (inBatchID, inUserID,  inBatchCount,  inBatchAmount, v_comBatchId,  0, outBatchStatus, 
                                         now(),  0,  inRoutingPoint, 'UnknownType',  inBatchUID)
     returning batchid into outComBatchID;

 end if;


EXCEPTION
WHEN OTHERS THEN
         RAISE EXCEPTION 'Unexpected error occured while retrieving batch status. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getbatchstatus(inbatchid character varying, inuserid integer, inbatchcount integer, inbatchamount character varying, inserviceid integer, inroutingpoint character varying, inbatchuid character varying, OUT outbatchstatus integer, OUT outcombatchid character varying) OWNER TO findata;

--
-- TOC entry 386 (class 1255 OID 62579)
-- Name: getbatchtype(character varying, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getbatchtype(inbatchid character varying, intablename character varying, insender character varying, OUT outbatchtype character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
                   03.Jun.2014, DenisaN
  Created:         20.Aug.2013, LucianP
  Description:     Gets the batch type for one given batch
  Parameters:      inBatchID  - batch identifier
                   inTableName - batch table
                   inSender - sender bank BIC
  Returns:         outBatchType  parameter representing the batch type
  Used:            FinTP/BASE/RE
***********************************************/          

v_stmt  character varying(250);

BEGIN

      if inSender = '' then           
         --  get batch type from outgoing batch storage
         v_stmt := 'select batchtype from findata.' || inTableName || ' t where batchid = $1'; 
         execute v_stmt into outBatchType using inBatchID;
      else
        -- get batch type from incoming batch storage
         v_stmt := 'select batchtype from findata.' || inTableName || ' t where batchid = $1 and sender = $2';
         execute v_stmt into outBatchType using inBatchID, inSender ;
      end if;

EXCEPTION
   WHEN NO_DATA_FOUND THEN 
         outBatchType := null;
   WHEN OTHERS THEN
         RAISE EXCEPTION 'Unexpected error occured while retrieving batch type. Message is: %', SQLERRM;
       
END;
$_$;


ALTER FUNCTION findata.getbatchtype(inbatchid character varying, intablename character varying, insender character varying, OUT outbatchtype character varying) OWNER TO findata;

--
-- TOC entry 462 (class 1255 OID 2022612)
-- Name: getbskpis(character varying, integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getbskpis(inentity character varying, inyear integer, OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  22.Feb.2021, LuisaP 15469
  Created:         22.Feb.2021, LuisaP 15469
  Description:    Gathers data for the Funds Transfer reporting according to the given filtering     
  Parameters:     inentity - entity 
                  inyear - year                         
  Returns:        cursor
  Used:           FinTP/BASE/UI Statements
***********************************************/

BEGIN

open outretcursor for
	select case when pl.omfp21 is not null and pl.omfp1 is not null then pl.omfp21/pl.omfp1*100 else null end as emplcostsinturnover,
			case when pl.omfp67 is not null and pl.omfp1 is not null then pl.omfp67/pl.omfp1*100 else null end  as  profitrate,
			case when bs.totalcapstr is not null and bs.totalact is not null then bs.totalcapstr/bs.totalact*100 else null end as debitratio,
			case when bs.omfp11 is not null and bs.omfp15 is not null then bs.omfp11/bs.omfp15 else null end as currentratio,
			case when pl.omfp67 is not null and bs.omfp48 is not null then pl.omfp67/bs.omfp48*100 else null end as roe,
			case when pl.omfp1 is not null and bs.totalact is not null then pl.omfp1/bs.totalact else null end as assetrurnoverratio,
			ROW_NUMBER() OVER (ORDER BY bs.year) AS id
	from findata.repbalancesheet bs full join findata.repprofitandloss pl on bs.year = pl.year and bs.entity = pl.entity
	where (bs.year = inyear and bs.entity = inentity) OR (pl.year = inyear and pl.entity = inentity);

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering messages. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getbskpis(inentity character varying, inyear integer, OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 359 (class 1255 OID 101636)
-- Name: getbusinessareabyid(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getbusinessareabyid(incorelid character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$

DECLARE

/************************************************
  Change history: dd.mon.yyyy  --  author  --   description                      
  Created:        06.Feb.2019 - DanielC - 13035
  Description:    Create routing jobs for given user actions;  
  Parameters:    incorelid   - correlation id
  Returns:       business area
  Used:          FinTP/BASE/UI
***********************************************/             

v_msgtype character varying;
v_area    character varying;
 
BEGIN

	select messagetype into v_msgtype from findata.routedmessages where correlationid = incorelid;
    select businessarea into v_area from fincfg.messagetypes where messagetype = v_msgtype;
    RETURN v_area;
    

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while creating routing job: %', SQLERRM;

END;

$$;


ALTER FUNCTION findata.getbusinessareabyid(incorelid character varying) OWNER TO findata;

--
-- TOC entry 388 (class 1255 OID 62580)
-- Name: getbusinessdateformat(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getbusinessdateformat(indate character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description                 
  Created:         03.Feb.2014, DenisaN 
  Description:     Returns business standard date format  
  Parameters:      inDate - date to be formatted		 
  Returns:         [yymmdd]
  Used:            FinTP/BASE/DB
***********************************************/


BEGIN

        
    if length(inDate) = 8 then
        return substr(inDate,3,6);
    elsif inDate like '%-%'  then 
        return substr(replace(inDate,'-',''),3,6);
    else
        return inDate;
    end if;
                   

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while inserting message: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getbusinessdateformat(indate character varying) OWNER TO findata;

--
-- TOC entry 447 (class 1255 OID 2031177)
-- Name: getcfcomparison(character varying, date); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getcfcomparison(inentity character varying, incfforecastdate date, OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE


/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  22.Feb.2021, LuisaP 15469
  Created:         22.Feb.2021, LuisaP 15469
  Description:    Generate Cashflow comparison
  Parameters:     inentity - entity 
                  incfforecastdate - casflow forecast date                         
  Returns:        cursor
  Used:           FinTP/BASE/UI Statements
***********************************************/
v_countcomparison integer;
v_countforcastgen integer;

BEGIN


PERFORM findata.getcfforest(inentity, incfforecastdate);


     select count(*) into v_countcomparison FROM findata.cfcomparison where accountbalancedate = incfforecastdate AND entity = inentity;

     select count(*) into v_countforcastgen FROM findata.cfforecastgendata 
			  where (indicator = 'Excedent/ Deficit disponibilitati in contul (Account Excedent/ Deficit):' or 
		 	  indicator = 'EXCEDENT/ DEFICIT DISPONIBILITATI COMPANIE (COMPANY EXCEDENT/ DEFICIT)') AND 
			  cfforecastdate = incfforecastdate AND entity = inentity;
 if (v_countcomparison > 0 and  v_countforcastgen > 0) then

	open outretcursor for
         select tmp.*, row_number() over () id from 
         (
		   select case   when cffcomp.iban is not null then 'Sold cont (Account Balance Amount)'
					     when cffcomp.iban is null then 'Sold companie (Company Balance Amount)' 
                  end as indicator,
				  cffcomp.* from
						(SELECT cfcomparison.balanceiban as iban,
							sum(cfcomparison.ronaccountbalanceamount) as amount,
							'RON' as currency,
							cfcomparison.accountbalancedate as accountdate
							FROM findata.cfcomparison
							where accountbalancedate = incfforecastdate AND entity = inentity
							group by currency, accountdate, ROLLUP (iban)
                         ) cffcomp
			UNION ALL
			select cfgendata.* from (
			    select indicator, operationiban as iban, amt as amount, operationcurrency as currency, cfforecastdate as accountdate
			    FROM findata.cfforecastgendata 
				where (indicator = 'Excedent/ Deficit disponibilitati in contul (Account Excedent/ Deficit)' or 
					  indicator = 'EXCEDENT/ DEFICIT DISPONIBILITATI COMPANIE (COMPANY EXCEDENT/ DEFICIT)') AND 
					  cfforecastdate = incfforecastdate AND entity = inentity
				      order by iban asc) cfgendata
			UNION ALL
			select case   when comp.iban is not null then 'Suma comparatie (Comparison amount)'
						  when comp.iban is null then 'Suma comparatie companie (Company comparison amount)'
					 end as indicator,
					 comp.* from 
                     (select total.iban, sum(total.amount) as amount, total.currency, total.accountdate from 
					  (select a.amount - b.amount as amount, a.iban, a.currency, a.accountdate from 
					   (SELECT cfcomparison.balanceiban as iban,
					        	sum(cfcomparison.ronaccountbalanceamount) as amount,
					        	'RON' as currency,
					        	cfcomparison.accountbalancedate as accountdate
					    FROM findata.cfcomparison
					    where accountbalancedate = incfforecastdate AND entity = inentity
					    group by currency, accountdate, ROLLUP (iban)
                        ) a 
					    INNER JOIN 
                        (SELECT operationiban as iban, amt as amount, operationcurrency as currency,cfforecastdate as accountdate
						 FROM findata.cfforecastgendata
						 where (indicator = 'Excedent/ Deficit disponibilitati in contul (Account Excedent/ Deficit)' or 
							   indicator = 'EXCEDENT/ DEFICIT DISPONIBILITATI COMPANIE (COMPANY EXCEDENT/ DEFICIT)') AND 
							   cfforecastdate = incfforecastdate AND entity = inentity
                        ) b
						 ON a.iban = b.iban AND a.accountdate = b.accountdate) total
						group by total.currency, total.accountdate, ROLLUP (total.iban)
                       ) comp
         ) tmp;

	
	 else
     null;

 end if;
	
EXCEPTION
WHEN NO_DATA_FOUND THEN 
         outretcursor := null;
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering messages. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getcfcomparison(inentity character varying, incfforecastdate date, OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 443 (class 1255 OID 2031173)
-- Name: getcfforest(character varying, date); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getcfforest(inentity character varying, incfforecastdate date) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  04.Nov.2021, dd 16188
                   22.Feb.2021, LuisaP 15469
  Created:         22.Feb.2021, LuisaP 15469
  Description:    Generate Cashflow forecast report     
  Parameters:     inentity - entity 
                  incfforecastdate - casflow forecast date                         
  Returns:        cursor
  Used:           FinTP/BASE/UI Statements
***********************************************/

v_currentid  integer;

BEGIN

 SELECT coalesce(max(id), 0) id FROM findata.cfforecastgendata ORDER BY id DESC LIMIT 1 into v_currentid;

 --overwrite existing report
 delete from findata.cfforecastgendata where entity = inentity and cfforecastdate = incfforecastdate;

 insert into  findata.cfforecastgendata(id,indicator, operationiban, amt, operationcurrency, cfforecastdate, entity) 
 select v_currentid + ROW_NUMBER() OVER (ORDER BY cffa.indicator desc) AS id, 
  cffa.indicator, cffa.operationiban, cffa.amt,  cffa.operationcurrency, cffa.cfforecastdate, cffa.entity
 from (select case when ope.operationtype = 'Incasare (Collection)' and ope.operationiban is not null then 'Total incasari in contul (Total Collections in Account):'
            when ope.operationtype = 'Incasare (Collection)' and ope.operationiban is null then 'TOTAL INCASARI COMPANIE (TOTAL COLLECTIONS IN COMPANY)'
            when ope.operationtype = 'Plata (Payment)' and ope.operationiban is not null then 'Total plati in contul (Total Payments from Account):'
            when ope.operationtype = 'Plata (Payment)' and ope.operationiban is null then 'TOTAL PLATI COMPANIE (TOTAL PAYMENTS FROM COMPANY)'
            when ope.operationtype = 'Sold initial (Initial Account Balance)' and ope.operationiban is not null then 'Sold initial cont (Initial Account Balance)'
            when ope.operationtype = 'Sold initial (Initial Account Balance)' and ope.operationiban is null then 'SOLD INITIAL COMPANIE (INITIAL COMPANY BALANCE)'
            when ope.operationtype = 'Excedent/deficit' and ope.operationiban is not null then 'Excedent/ Deficit disponibilitati in contul (Account Excedent/ Deficit)'
            when ope.operationtype = 'Excedent/deficit' and ope.operationiban is null then 'EXCEDENT/ DEFICIT DISPONIBILITATI COMPANIE (COMPANY EXCEDENT/ DEFICIT)'
          end as indicator, 
         operationiban, amt, operationcurrency,  incfforecastdate as cfforecastdate, inentity as entity,
         disporder
from
(
select * from
(
--initial account balance
select operationamount amt, operationiban, operationtype, operationcurrency,
        incfforecastdate as cfforecastdate, inentity as entity, 1 as disporder
from findata.cfforecast
where operationtype like 'Sold%'

union

--initial account total
select sum(operationamount) amt, null as operationiban, 'Sold initial (Initial Account Balance)' operationtype, 
       'RON', incfforecastdate as cfforecastdate, inentity as entity, 1 as disporder
from findata.cfforecast
where operationtype like 'Sold%'
group by operationtype
 
union

--operation totals
select sum(operationamount) amt, operationiban, 
       operationtype, operationcurrency, incfforecastdate as cfforecastdate, inentity as entity, 2 as disporder
from(
select cfops.*, cfinit.issuedate issuedatex from
(select * from findata.cfforecast
where entity = inentity 
  and ((maturitydate <= incfforecastdate and operationtype not like 'Sold%'))
) cfops
left join
(select * from findata.cfforecast where entity = inentity and operationtype like 'Sold%') cfinit
on cfops.operationiban = cfinit.operationiban
) allops
where maturitydate >= issuedatex
group by operationtype, operationcurrency, rollup (operationiban)
order by operationtype, operationiban

) allind

union

select sum(amt), operationiban, operationtype, operationcurrency, 
incfforecastdate as cfforecastdate, inentity as entity, 3 as disporder 
from
(
select si.amt + coalesce(opsinc.amt, 0) - coalesce (opspaym.amt, 0) amt,
       si.operationiban, 'Excedent/deficit' as operationtype, 
       si.operationcurrency,   incfforecastdate as cfforecastdate, inentity as entity, 3 as disporder
       
    from
(select operationamount amt, operationiban, operationtype, operationcurrency,
        incfforecastdate as cfforecastdate, inentity as entity, 1 as disporder
from findata.cfforecast
where operationtype like 'Sold%')si

left join

(select sum(operationamount) amt, operationiban, 
       operationtype, operationcurrency, incfforecastdate as cfforecastdate, inentity as entity, 2 as disporder
from(
select cfops.*, cfinit.issuedate issuedatex from
(select * from findata.cfforecast
where entity = inentity 
  and ((maturitydate <= incfforecastdate and operationtype like 'Inca%'))
) cfops
left join
(select * from findata.cfforecast where entity = inentity and operationtype like 'Sold%') cfinit
on cfops.operationiban = cfinit.operationiban
) allops
where maturitydate >= issuedatex
group by operationtype, operationcurrency, operationiban--, rollup (operationiban)
order by operationtype, operationiban
) opsinc
on opsinc.operationiban = si.operationiban
left join
(select sum(operationamount) amt, operationiban, 
       operationtype, operationcurrency, incfforecastdate as cfforecastdate, inentity as entity, 2 as disporder
from(
select cfops.*, cfinit.issuedate issuedatex from
(select * from findata.cfforecast
where entity = inentity 
  and ((maturitydate <= incfforecastdate and operationtype like 'Pla%'))
) cfops
left join
(select * from findata.cfforecast where entity = inentity and operationtype like 'Sold%') cfinit
on cfops.operationiban = cfinit.operationiban
) allops
where maturitydate >= issuedatex
group by operationtype, operationcurrency, operationiban--, rollup (operationiban)
order by operationtype, operationiban)opspaym
on opspaym.operationiban = si.operationiban
) allexc
group by operationtype, operationcurrency, rollup (operationiban)
) ope
order by disporder, indicator, operationiban) cffa
order by disporder, id;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering messages. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getcfforest(inentity character varying, incfforecastdate date) OWNER TO findata;

--
-- TOC entry 392 (class 1255 OID 62584)
-- Name: getduplicatemsgdetails(character varying, integer, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getduplicatemsgdetails(inmsgid character varying, inlivearch integer, inqueuename character varying, OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         05.Jun.2014, DenisaN - 8442
  Description:     Gets message details and feedback for all duplicates of one given message 
  Parameters:      inMsgID      - message identifier      
                   inLiveArch   - 1- live message/ 0- archived message      
                   inQueueName  - duplicate queue name / if null, message selected from Duplicate Report      
  Returns:         cursor
  Used:            FinTP/2D/UI
***********************************************/     

v_hash         varchar(32);
v_dupQueue     varchar(35);
v_stmt         varchar(3000);
v_senderapp    varchar(35);
v_insertdate   date;
v_startdate    date;
v_enddate      date;
v_period       integer;



BEGIN


  --TODO: enable archive search

if inLiveArch = 1 then

with  
    MH    as ( select routedmessageid, hash, date_trunc('day', insertdate) insertdate from findata.messagehashes 
                        where routedmessageid = inmsgid and length(hash) > 0) ,
    RM    as ( select id, correlationid, messagetype, requestorservice  from findata.routedmessages where id =  inmsgid)
        select    mh.hash, rm.requestorservice, mh.insertdate 
             into v_hash, v_senderapp, v_insertdate
         from  mh  
            join rm on mh.routedmessageid = rm.id;  
/*          
else   
  with  
    MH    as ( select   messageid, hash, date_trunc('day', insertdate) insertdate  from messagehashes   where messageid= inMsgID
                   union 
                   select   messageid, hash, date_trunc('day', insertdate) insertdate  from finarch.messagehashes   where messageid= inMsgID 
             ) ,
    RM   as ( select guid, correlationid, msgtype, senderapp from finarch.routedmessages where guid =  inMsgID),
 select mh.hash, senderapp, insertdate 
  into v_hash,  v_senderapp, v_insertdate
 from  mh  
 join bm on messageid = rm.guid;
*/
end if;


    --get duplicate detection period for optimizing the search; to be done specific params
    --select value::integer into v_period from fincfg.params where replace(upper(name),' ','') = 'DUPLICATEDETECTIONPERIOD';
    --v_startdate := fincfg.getlastbusinessday(v_insertdate,v_period);
    --v_enddate := fincfg.getlastbusinessday(v_insertdate,-1 * v_period);

v_stmt:='with  '||
          ' MHASHES as ( select routedmessageid from findata.messagehashes where hash = $1'||  
                       --and date_trunc(''day'', insertdate) >= $2
                      --  ' and date_trunc(''day'', insertdate) <= $3
                         ' ) ,'||
           ' RMLIVE   as ( select id, reference, messagetype, correlationid, 1 LiveArch from findata.routedmessages ),'||           
           ' FBLIVE   as ( select correlationid, payload, '||
                             '   case '||
                             '     when mqid is null and interfacecode is null and networkcode is null and correspondentcode is null and applicationcode is null then ''New'' '||
                             '     when interfacecode = ''FTP00'' then ''Received'' '||
                             '     when applicationcode is not null and applicationcode!= ''FTP12'' then ''User action: ''||applicationcode '||
                             '     when mqid is not null and interfacecode != ''FTP00'' then ''Sent: ''||coalesce(applicationcode, correspondentcode, networkcode, interfacecode,'' '') '||
                             '     else ''Unknown'' '||
                             '  end feedback, sourcefilename  '||
                         ' from findata.feedbackagg ) '||     
        ' select rmlive.id, rmlive.correlationid, coalesce(rmlive.reference,'' '') reference, rmlive.livearch, fblive.feedback, fblive.sourcefilename '||
        ' from  mhashes  '||
        ' join rmlive on mhashes.routedmessageid = rmlive.id  '||
        ' join fblive on rmlive.correlationid = fblive.correlationid ';
                      
v_stmt:=' select dup.id, dup.correlationid, dup.reference, dup.livearch, dup.feedback, dup.sourcefilename, '|| 
                  ' case '||
                  ' when q.queuename is null then ''n/a'' else q.queuename '
                                 ' end queuename 

                                 from ('||v_stmt;
v_stmt:=v_stmt||'  ) dup left join (select correlationid, id, queuename from findata.entryqueue where queuename = $2) q on dup.correlationid = q.correlationid' ;
      
--dupQueue: 2-original message; 1- message in queue; 0- message not in queue    
if inQueueName is not null then 
    --duplicate queue message details        
   open outretcursor for execute v_stmt using v_hash, /*v_startdate, v_enddate,*/ inQueueName;
        
else 
   --duplicate report message details       
   select duplicatequeue into v_dupQueue from fincfg.servicemaps where name = v_senderapp;
   open outretcursor for execute v_stmt using v_hash, v_startdate, v_enddate, v_dupQueue;

end if;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering messages. Message is: %', SQLERRM;
       
END;
$_$;


ALTER FUNCTION findata.getduplicatemsgdetails(inmsgid character varying, inlivearch integer, inqueuename character varying, OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 456 (class 1255 OID 217827)
-- Name: geteventdetails(character varying); Type: FUNCTION; Schema: findata; Owner: postgres
--

CREATE FUNCTION findata.geteventdetails(ineventcorrid character varying, OUT outretcursortx refcursor, OUT outretcursor refcursor) RETURNS record
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:
  Created:        10.Dec.2020, dd 14522
  Description:    Gathers tx data related to an event
  Parameters:     ineventid - event unique identifier
  Returns:        cursor
  Used:           FinTPc/BASE/UI
***********************************************/

BEGIN

open outretcursortx for
     select correlationid, reference, updatedate, userid from findata.routedmessages where
     correlationid = ineventcorrid;

open outretcursor for
     select correlationid, message, additionalinfo, innerexception from findata.repevents where
     correlationid = ineventcorrid;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering eventdata. Message is: %', SQLERRM;

END;
$$;


ALTER FUNCTION findata.geteventdetails(ineventcorrid character varying, OUT outretcursortx refcursor, OUT outretcursor refcursor) OWNER TO postgres;

--
-- TOC entry 389 (class 1255 OID 62587)
-- Name: getfirstjob(); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getfirstjob(OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         17.May.2013, DenisaN 7164
  Description:     Returns the count of new routing jobs. 
  Parameters:      n/a
  Returns:         count
  Used:            FinTP/BASE/RE
***********************************************/

BEGIN

open outRetCursor for
   select count(status) as outCount from findata.routingjobs where status = 0;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering job info: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getfirstjob(OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 390 (class 1255 OID 62588)
-- Name: getfirstnewjob(); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getfirstnewjob(OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         17.May.2013, DenisaN 7164
  Description:     Returns first new job by highest priority and marks it as 'in process' 
  Parameters:      n/a
  Returns:         cursor result set
  Used:            FinTP/BASE/RE
***********************************************/

v_guid      findata.routingjobs.id%type;

BEGIN

  update findata.routingjobs set status = -1 where id in 
   (select id from (select id from findata.routingjobs where status = 0 order by priority desc)rj limit 1) 
  returning id into v_guid;
  
  open outretcursor for
    select id, status,  backout,  priority,  routingpoint, function, userid
    from findata.routingjobs where id = v_guid;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering job: % ', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getfirstnewjob(OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 391 (class 1255 OID 62591)
-- Name: getftpayments(character varying, character varying, character varying, character varying, character varying, character varying, character varying, numeric, numeric, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getftpayments(insdatemin character varying, insdatemax character varying, inmsgtype character varying, insender character varying, inreceiver character varying, inref character varying, invdate character varying, inamtmin numeric, inamtmax numeric, inccy character varying, indacc character varying, indcname character varying, inordbank character varying, inbenbank character varying, incacc character varying, inccname character varying, inservice character varying, indirect character varying, instate character varying, inbatchid character varying, inuserid integer, inqname character varying, inordfield character varying, inorddir character varying, inllimit integer, inulimit integer, OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  05.Jun.2015, CRaluca 8817
  Created:         21.Mar.2014, DenisaN 8307
  Description:    Gathers data for the Funds Transfer reporting according to the given filtering     
  Parameters:     insdatemin - low date interval value
                  insdatemax - high date interval value
                  inmsgtype  - message type
                  insender   - sender BIC
                  inreceiver - receiver BIC
                  inref      - tx reference
                  invdate    - value date
                  inamtmin   - low amount interval value
                  inamtmax   - high amount interval value
                  inccy      - currency
                  indacc     - dbt account
                  indcname   - dbt cust name
                  inordbank  - ordering bank
                  inbenbank  - beneficiary bank
                  incacc     - cdt account
                  inccname   - cdt cust name
                  inservice  - service
                  indirect   - I/O direction
                  instate    - tx state
                  inbatchid  - batchid
                  inuserid   - user identifier
                  inqname    - queue name
                  inordfield - order by field
                  inorddir   - order by direction 
                  inllimit   - low limit / msg per page
                  inulimit   - upper limit / msg per page                          
  Returns:        cursor
  Used:           FinTP/BASE/UI Funds Transfer
***********************************************/

BEGIN


open outretcursor for execute
'select * from ('||
 ' select tmp.*, max(tmp.rnum) over() rnummax'||
 ' from ( '||
 ' select  row_number() over (order by '||coalesce(inordfield, 'insertdate ')||' '||coalesce(inorddir, ' desc')||' ) rnum, '||   
         ' insertdate, ''test'' messagetype, sender, receiver, reference, valuedate, amount, currency,	'||
         ' dbtaccount, dbtcustomername, orderingbank, beneficiarybank, cdtaccount, cdtcustomername, service, '||
         ' direction, case when errcode is null then state '||
                         ' else state||'' [''||errcode||'']'' '||
                    ' end state, batchid, userid, correlationid, queuename ' ||
  ' from findata.repstatft '||
  ' where insertdate >= to_timestamp($1,''dd mm yyyy hh24:mi:ss'') and insertdate <= to_timestamp($2,''dd mm yyyy hh24:mi:ss'') '||
       ' and  ( $3 is null or  messagetype = $4 )'||
       ' and  ( $5 is null or lower(sender) = lower($6) ) '||       
       ' and  ( $7 is null or lower(receiver) = lower($8) ) '||       
       ' and  ( $9 is null or lower(reference) like lower(''%''||$10||''%'')) '||
       ' and  ( $11 is null or valuedate = $12) ' ||
       ' and ( (amount >= coalesce($13,0) and amount <= coalesce($14,99999999999999999999) ) )'||
       ' and ( $15 is null or currency = $16 ) ' ||
       ' and ( $17 is null or lower(dbtaccount) like lower(''%''||$18||''%'')) ' ||
       ' and ( $19 is null or lower(dbtcustomername) like lower(''%''||$20||''%'') ) ' ||
       ' and ( $21 is null or lower(orderingbank) = lower($22)) ' ||
       ' and ( $23 is null or lower(beneficiarybank) = lower($24)) '||
       ' and ( $25 is null or lower(cdtaccount) like lower(''%''||$26||''%'')) ' ||
       ' and ( $27 is null or lower(cdtcustomername) like lower(''%''||$28||''%'')) ' ||
       ' and ( $29 is null or service = $30) ' ||
       ' and ( $31 is null or direction = $32) ' ||
       ' and ( $33 is null or state = $34) ' ||
       ' and ( $35 is null or lower(batchid) like lower(''%''||$36||''%'')) ' ||
       ' and ( $37 is null or userid = $38 ) ' ||
       ' and ( $39 is null or lower(queuename) = lower($40 )) ' ||
  ' order by '||coalesce(inordfield, 'insertdate')||' '||coalesce(inorddir, 'desc')||') tmp ) tmp1'||
  ' where rnum > coalesce($41,0) and rnum <= coalesce($42,100)+ coalesce($43,0)'
using insdatemin, insdatemax, inmsgtype, inmsgtype, insender, insender, inreceiver, inreceiver, inref, inref,  invdate, invdate, inamtmin, inamtmax,
      inccy, inccy, indacc, indacc, indcname, indcname,  inordbank, inordbank, inbenbank, inbenbank, incacc, incacc, inccname, inccname,  inservice, inservice,  
      indirect, indirect, instate, instate, inbatchid, inbatchid,  inuserid,  inuserid,inqname,inqname,  inllimit, inulimit, inllimit;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering messages. Message is: %', SQLERRM;
       
END;
$_$;


ALTER FUNCTION findata.getftpayments(insdatemin character varying, insdatemax character varying, inmsgtype character varying, insender character varying, inreceiver character varying, inref character varying, invdate character varying, inamtmin numeric, inamtmax numeric, inccy character varying, indacc character varying, indcname character varying, inordbank character varying, inbenbank character varying, incacc character varying, inccname character varying, inservice character varying, indirect character varying, instate character varying, inbatchid character varying, inuserid integer, inqname character varying, inordfield character varying, inorddir character varying, inllimit integer, inulimit integer, OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 361 (class 1255 OID 147239)
-- Name: getgroupsformtqueue(character varying, character varying, numeric, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getgroupsformtqueue(inqueuename character varying, inmsgtype character varying, inamount numeric, inreference character varying, OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history: dd.mon.yyyy  --  author  --   description
                  22.Aug.2014, DenisaN 8539                        
  Created:        27.Mar.2014, DenisaN 7488
  Description:    Returns the group header / grouping criteria for the given message type;
                  may filter trx in groups
  Parameters:     inqueuename - queue name
                  inmsgtype - message type
                  inamount  - filter: trx amount
                  inreference - filter: reference
  Returns:        cursor
  Used:           FinTP/BASE/UI
***********************************************/             

v_groupfields          varchar(1000);
v_groupaliasfields     varchar(1000);
v_qreportingview       varchar(35);
v_timekey              varchar(17);

  
  
BEGIN

  --timekey
  select to_char(now(), 'ddmmyyyyhh24:mi:ss') into v_timekey;

  --get specific storage
  select reportingstorage into v_qreportingview from fincfg.messagetypes where messagetype = inmsgtype;

  --get specific group fields
  select case when routingkeyword1 is not null then lower(routingkeyword1) else ' ' end ||
         case when routingkeyword2 is not null then ', '||lower(routingkeyword2) else ' ' end ||
         case when routingkeyword3 is not null then ', '||lower(routingkeyword3) else ' ' end ||
         case when routingkeyword4 is not null then ', '||lower(routingkeyword4) else ' ' end ||
         case when routingkeyword5 is not null then ', '||lower(routingkeyword5) else ' ' end, 
         case when routingkeyword1 is not null then routingkeyword1 else ' ' end ||
         case when routingkeyword2 is not null then ', '||routingkeyword2 else ' ' end ||
         case when routingkeyword3 is not null then ', '||routingkeyword3 else ' ' end ||
         case when routingkeyword4 is not null then ', '||routingkeyword4 else ' ' end ||
         case when routingkeyword5 is not null then ', '||routingkeyword5 else ' ' end
  into v_groupaliasfields, v_groupfields
  from fincfg.queuemessagegroups where messagetype = inmsgtype;


  --get tx groups (if defined) along with assigned keys
  if v_groupfields is null then
     if inmsgtype = 'Undefined' then
        open outretcursor for execute
           ' select '', '', 0.00 as totamt, 
count(*) cnt, null timekey, null groupkey '||
        ' from findata.'||v_qreportingview||' where queuename = $1 '
        --' group by requestorservice '||
       -- ' order by requestorservice'
     using inqueuename;
     else
     open outretcursor for execute 
        'select ''X'' where 1 = 2';
     end if;
  else     
     open outretcursor for execute 
        ' select '||v_groupaliasfields||', sum(to_number( CASE 
    WHEN (
      rtrim((amount)::text) IS NULL
    ) THEN ''0,00''::text 
    WHEN (
      rtrim((amount)::text) = ''''::text
    ) THEN ''0,00''::text 
    WHEN (
      rtrim((amount)::text) = '',''::text
    ) THEN ''0,00''::text 
    ELSE replace(rtrim((amount)::text), '',''::text, ''.''::text) 
  END, ''FM99999999999999999D99''::text)) totamt, 
count(*) cnt, '||
              ''''||v_timekey||''' timekey, md5(string_agg(id,'''' order by id)) groupkey '||
        ' from findata.'||v_qreportingview||' where queuename = $1 '||
   --     ' and ($2 is null or (upper(reference) like (''%''||$3||''%'') or amount = $4))'||
        ' group by '||v_groupfields||
        ' order by '||v_groupfields
     using inqueuename, inreference, inreference, inamount;
  end if;
  
  
EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering messages: %', SQLERRM;

END;
$_$;


ALTER FUNCTION findata.getgroupsformtqueue(inqueuename character varying, inmsgtype character varying, inamount numeric, inreference character varying, OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 362 (class 1255 OID 147243)
-- Name: getgroupsheaderformtqueue(character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getgroupsheaderformtqueue(inmsgtype character varying, inheadertype character varying, OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history: 11.Jun.2018, DanielC 12857
                  26.Apr.2018, DanielC 12692                      
  Created:        27.Mar.2014, DenisaN 7488
  Description:    Returns the group header / grouping criteria for the given message type
  Parameters:     inmsgtype - message type
                  inheadertype - T - transaction level
                                 G - transaction group level
  Returns:        cursor
  Used:           FinTP/BASE/UI
***********************************************/             

  
BEGIN

if inheadertype = 'G' then 

open outretcursor for 
    select kwn.description kfname, lower(fields.kword) kname, rnum from
     (select kword, row_number() over() rnum from
             ( select unnest(string_to_array(xx,',')) kword from
               (select coalesce(routingkeyword1,' ')||','||coalesce(routingkeyword2,' ')||','||
                       coalesce(routingkeyword3,' ')||','||coalesce(routingkeyword4,' ')||','||
                       coalesce(routingkeyword5, ' ') xx
                from  fincfg.queuemessagegroups where messagetype = inmsgtype
               )kwarr
             )kws
      ) fields                  
   join fincfg.routingkeywords kwn
   on fields.kword = kwn.name
    union
   select 'Total Amount' kfname, 'totamt' kname, 6 rnum
    union
   select 'No. of transactions' kfname, 'cnt' kname, 7 rnum 
  order by rnum;


elsif inheadertype = 'T'then
  	
    open outretcursor for
    	select label, routingkeywordname, displayorder, contenttype from fincfg.queuemessagetrxheader
        where messagetype = inmsgtype
        order by displayorder;
        
end if;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering messages: %', SQLERRM;

END;
$$;


ALTER FUNCTION findata.getgroupsheaderformtqueue(inmsgtype character varying, inheadertype character varying, OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 393 (class 1255 OID 62598)
-- Name: gethash(character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.gethash(inservicename character varying, inmessageid character varying, OUT outcount integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         17.Feb.2014, DenisaN
  Description:     Gets the total number of identical hashes, for one given message    
  Parameters:      inServiceName - service identifier   
                   inMessageID -  message identifier
  Returns:         no. of appearances
  Used:            FinTP/2D/RE
***********************************************/

BEGIN
          
          
  select count (*) into outCount  from findata.messagehashes where  servicename = inServiceName
             and hash = (select hash from findata.messagehashes where servicename = inServiceName and routedmessageid = inMessageID );
          



EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while getting hash: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.gethash(inservicename character varying, inmessageid character varying, OUT outcount integer) OWNER TO findata;

--
-- TOC entry 394 (class 1255 OID 62599)
-- Name: getimageforcsm(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getimageforcsm(OUT outretcursor refcursor, incorrelationid character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         09.May.2014, DenisaN 8380
  Description:     Extracts transaction attached image 
  Parameters:      inCorrelID -  message correlation identifier
  Returns:         cursor
  Used:            FinTP/BASE/CONN
***********************************************/

BEGIN

  open outRetCursor for 

     select payload, imageref from findata.blobsqueue where correlationid = inCorrelationID; 


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing image: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getimageforcsm(OUT outretcursor refcursor, incorrelationid character varying) OWNER TO findata;

--
-- TOC entry 434 (class 1255 OID 62600)
-- Name: getmessagesinbatch(character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getmessagesinbatch(OUT outretcursor refcursor, inbatchid character varying, inbatchissuer character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description 
  Created:         02.Dec.2013, DenisaN
  Description:     Gets all messages in the specified batch
  Parameters:      inBatchID    - batch identifier
                   inBatchIssuer  - not used                                                                                                                                   
  Returns:         outCursor  parameter representing Cursor result set
  Used:            FinTP/BASE/RE
***********************************************/


BEGIN

 open outRetCursor for
    select correlationid, batchsequence, reference, requestorservice from findata.feedbackagg where batchid = inBatchID;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while retrieving messages in batch. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getmessagesinbatch(OUT outretcursor refcursor, inbatchid character varying, inbatchissuer character varying) OWNER TO findata;

--
-- TOC entry 396 (class 1255 OID 62601)
-- Name: getmessagesinbatchrfd(character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getmessagesinbatchrfd(OUT outretcursor refcursor, inbatchid character varying, inbatchissuer character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history: dd.mon.yyyy  --  author  --   description                        
  Created:        19.May.2014, DenisaN
  Description:    Returns all messages in given batch that are not refused; 
                  used for msgs accepting refusal. 
  Parameters:     inBatchID      - batch identifier
                  inBatchIssuer  - batch issuer bank
  Returns:        cursor
  Used:           FinTP/BASE/RE
***********************************************/  


BEGIN

--if issuer is specified
if  length( inBatchIssuer ) > 0  then
  
  open outRetCursor for
    select correlationid, batchsequence, reference, requestorservice from findata.feedbackagg 
        where batchid = inBatchID and issuer = inBatchIssuer 
         and (correspondentcode not like 'RFD%' or correspondentcode is null) ;

--if issuer is not specified
else    

  open outRetCursor for   
    select correlationid, batchsequence, reference, requestorservice from findata.feedbackagg
           where batchid = inBatchID and (correspondentcode not like 'RFD%' or correspondentcode is null);
           
end if;
  
EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering messages in batch: %', SQLERRM;

END;
$$;


ALTER FUNCTION findata.getmessagesinbatchrfd(OUT outretcursor refcursor, inbatchid character varying, inbatchissuer character varying) OWNER TO findata;

--
-- TOC entry 397 (class 1255 OID 62609)
-- Name: getnextservicesequence(integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getnextservicesequence(inservice integer, OUT outsequence integer) RETURNS integer
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         27.Aug.2013, LucianP
  Description:     Gets the next sequence (used in batch identifier) for the specified service
  Parameters:      inService -  service identifier
  Returns:         outSequence parameter representing the sequence to be used
  Used:            FinTP/BASE/RE
***********************************************/

v_service    fincfg.servicemaps.name%type;

BEGIN

  select name into v_service from fincfg.servicemaps where id = inService;

  select nextval('findata.commbatchseq') into outSequence;

EXCEPTION
   WHEN NO_DATA_FOUND THEN 
         RAISE EXCEPTION 'Service not found.';
   WHEN OTHERS THEN
         RAISE EXCEPTION 'Unexpected error occured while generating batch sequence. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getnextservicesequence(inservice integer, OUT outsequence integer) OWNER TO findata;

--
-- TOC entry 398 (class 1255 OID 62610)
-- Name: getoriginalmessageid(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getoriginalmessageid(incorrelid character varying, OUT outmsgid character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         17.May.2013, DenisaN 7164
  Description:     Gets the original message identifier [ guid ]
  Parameters:      inCorrelID -  message correlation identifier
  Returns:         message guid
  Used:            FinTP/BASE/RE
***********************************************/


BEGIN

  select id into outMsgID from findata.routedmessages where correlationid = inCorrelID;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing message: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getoriginalmessageid(incorrelid character varying, OUT outmsgid character varying) OWNER TO findata;

--
-- TOC entry 399 (class 1255 OID 62611)
-- Name: getoriginalpayload(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getoriginalpayload(OUT outrefcursor refcursor, inmsgid character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE
                                                                                                    
/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/                                                                                                         
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         17.May.2013, DenisaN 7164
  Description:     Returns the original message payload
  Parameters:      inMsgID -  message  identifier
  Returns:         cursor result set
  Used:            FinTP/BASE/RE
***********************************************/

BEGIN

 open outrefcursor for
    select payload from findata.history where id = inMsgID;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing message: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getoriginalpayload(OUT outrefcursor refcursor, inmsgid character varying) OWNER TO findata;

--
-- TOC entry 401 (class 1255 OID 62612)
-- Name: getoriginalref(character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getoriginalref(intrn character varying, inbatchid character varying, OUT outref character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  11.Jun.2018, DanielC 12857                             
  Created:         10.Feb.2014, DenisaN
  Description:     Gets the refusal transaction reference.
  Parameters:      inTrn -  original message transaction reference
                   inBatchID - refusal batch identifier
  Returns:         outRef parameter reperesenting refusal transaction reference 
  Used:            FinTP/BASE/RE
***********************************************/


--TO REVIEW: - unicitate pe trn cand search for msgtype
--           - move trn into specific tables
--  

v_storage varchar(35);
v_stmt    varchar(1000);

BEGIN

       --get original message type & storage        
       select storage into v_storage from fincfg.messagetypes where messagetype in (select messagetype  from findata.routedmessages where reference = inTRN);
         
       --get refusal reference
       v_stmt :=  ' select reference from '||
                                   ' ( select correlationid, reference from findata.feedbackagg where batchid = $1 ) fb '||
                            ' join '|| 
                                    ' ( select correlationid from findata.'||v_storage||' where originalreference = $2 ) mt '||
                             ' on fb.correlationid = mt.correlationid ';  
      execute v_stmt into outRef using inBatchID, inTrn;
      
      
EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while retrieving reference: %', SQLERRM;
       
END;
$_$;


ALTER FUNCTION findata.getoriginalref(intrn character varying, inbatchid character varying, OUT outref character varying) OWNER TO findata;

--
-- TOC entry 402 (class 1255 OID 62613)
-- Name: getpymtpayments(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, numeric, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getpymtpayments(insdatemin character varying, insdatemax character varying, inmsgtype character varying, inendtoendid character varying, intrn character varying, indbtname character varying, indbtaccount character varying, inordbank character varying, inamount numeric, incurrency character varying, invaluedate character varying, inacctcode character varying, inloccode character varying, inbudgcode character varying, instatus character varying, incdtname character varying, incdtaccount character varying, inbenbank character varying, insourcefname character varying, indestfname character varying, inordfield character varying, inorddir character varying, inllimit integer, inulimit integer, OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history: dd.mon.yyyy  --  author  --   description 
  Created:        20.Jun.2018, DanielC 12889
  Description:    Gathers data for the Payments Instructions reporting according to the given filtering     
  Parameters:   insdatemin - low date interval value
                insdatemax - high date interval value   
  				inmsgtype  - message type
  				inendtoendid - end to end identification
    			intrn - transaction reference
    			indbtname - debtor name
    			indbtaccount - debtor account
    			inordbank - debtor agent bic
    			inamount - amount
    			incurrency - currency
    			invaluedate - requested execution date
    			inacctcode - accounting code
    			inloccode - location code
    			inbudgcode - budget code
    			instatus - status
    			incdtname - creditor name
          		incdtaccount - creditor account
    			inbenbank - creditor agent bic
    			insourcefname - source file name
    			indestfname - destination file name
                inordfield - order by field
                inorddir   - order by direction 
                inllimit   - low limit / msg per page
                inulimit   - upper limit / msg per page  
   Returns:        cursor
   Used:           FinTP/BASE
***********************************************/ 

BEGIN

open outretcursor for execute
'select * from (' ||
'  select tmp.*, max(tmp.rnum) over() rnummax' ||
'  from ( ' ||
'    select  row_number() over (order by '||coalesce(inordfield, 'insertdate ')||' '||coalesce(inorddir, 'desc')||' ) rnum, '|| 
'            correlationid, messagetype, endtoendid, reference, dbtcustomername, dbtaccount, ' ||
'            orderingbank, amount, currency, valuedate, accountingcode, locationcode, ' ||
'            budgetcode, status, coalesce(currentqueue, ''n/a'') currentqueue, cdtcustomername, cdtaccount, ' ||
'            beneficiarybank, sourcefilename, destinationfilename, remittanceinfo ' ||
'    from findata.repstatpymt'
'    where insertdate >= to_timestamp($1,''DD/MM/YYYY'') and insertdate <= to_timestamp($2,''DD/MM/YYYY'') '||
'          and  ( $3 is null or  messagetype = $4 )' ||
'          and  ( $5 is null or lower(endtoendid) like lower(''%''||$6||''%''))' ||
'          and  ( $7 is null or lower(reference) like lower(''%''||$8||''%''))' || 
'          and  ( $9 is null or lower(dbtcustomername) = lower($10) ) '|| 
'          and  ( $11 is null or dbtaccount = $12 ) '||
'          and  ( $13 is null or orderingbank = $14 ) '||
'          and  ( $15 is null or amount = $16 ) '||
'          and  ( $17 is null or currency = $18 ) '||
'          and  ( $19 is null or to_date(valuedate, ''YYMMDD'') = to_date($20, ''DD/MM/YYYY'') ) '||
'          and  ( $21 is null or accountingcode = $22 ) '||
'          and  ( $23 is null or locationcode = $24 ) '||
'          and  ( $25 is null or budgetcode = $26 ) '||
'          and  ( $27 is null or status = $28 ) '||
'          and  ( $29 is null or lower(cdtcustomername) = lower($30) ) '||
'          and  ( $31 is null or cdtaccount = $32 ) '||
'          and  ( $33 is null or beneficiarybank = $34 ) '||
'          and  ( $35 is null or lower(sourcefilename) like lower(''%''||$36||''%'')) '||
'          and  ( $37 is null or lower(destinationfilename) like lower(''%''||$38||''%'')) '||
' order by '||coalesce(inordfield, 'insertdate')||' '||coalesce(inorddir, 'desc')||') tmp ) tmp1'||
' where rnum > coalesce($39,0) and rnum <= coalesce($40,100)+ coalesce($41,0)'
using insdatemin, insdatemax, inmsgtype, inmsgtype, inendtoendid, inendtoendid, intrn, intrn,
       indbtname, indbtname, indbtaccount, indbtaccount, inordbank, inordbank, inamount, inamount,
       incurrency, incurrency, invaluedate, invaluedate, inacctcode, inacctcode, inloccode, inloccode,
       inbudgcode, inbudgcode, instatus, instatus, incdtname, incdtname, incdtaccount, incdtaccount,
       inbenbank, inbenbank, insourcefname, insourcefname, indestfname, indestfname, inllimit, inulimit, inllimit;
       

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering messages. Message is: %', SQLERRM;
       
END;
$_$;


ALTER FUNCTION findata.getpymtpayments(insdatemin character varying, insdatemax character varying, inmsgtype character varying, inendtoendid character varying, intrn character varying, indbtname character varying, indbtaccount character varying, inordbank character varying, inamount numeric, incurrency character varying, invaluedate character varying, inacctcode character varying, inloccode character varying, inbudgcode character varying, instatus character varying, incdtname character varying, incdtaccount character varying, inbenbank character varying, insourcefname character varying, indestfname character varying, inordfield character varying, inorddir character varying, inllimit integer, inulimit integer, OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 406 (class 1255 OID 62616)
-- Name: getqueuetxno(); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getqueuetxno(OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/

/************************************************
  Change history: dd.mon.yyyy  --  author  --   description
  Created:        04.Sep.2018, dd
  Description:    Returns all queues and current no of tx
  Parameters:     
  Returns:        n/a
  Used:          FinTP/BASE/UI
***********************************************/

BEGIN

open outretcursor for execute
    'select x.id, x.name as queuename, x.label, coalesce(x.txno, 0) nooftx
    from ((select id, name, label from fincfg.queues) q 
         left join (select queuename, count(id) txno from findata.entryqueue group by queuename) eq 
         on q.name = eq.queuename) x'; 

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while getting queueus: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getqueuetxno(OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 407 (class 1255 OID 62617)
-- Name: getstatus(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getstatus(incorrelid character varying) RETURNS character varying
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         19.Jun.2018, DanielC 12889
  Description:     Function that uses a given correlation identifier and
                   returns the status of the specific message
  Parameters:     inCorrelId - correlation identifier                        
  Returns:        status as character varying
  Used:           FinTP/BASE/RE
***********************************************/

 v_queueId     integer;
 v_appcode 	   character varying(10);
 v_qtypeName   fincfg.queuetypes.name%type;
 v_status      character varying(140);
 v_qlabel      fincfg.queues.label%type;

BEGIN

	select currentqueue into v_queueId from findata.routedmessages
    where correlationid = incorrelid;
    
    if (v_queueId is null) then
    	
        select applicationcode into v_appcode from findata.feedbackagg
        where correlationid = incorrelid;
        
        case when v_appcode = 'FTP09' then v_status := 'Completed - Rejected (reason: others)';
             when v_appcode = 'FTP19' then v_status := 'Completed - Suspended (reason: others)';
             when v_appcode = 'PDM00' then v_status := 'Completed - Rejected (reason: duplicate)';
             when v_appcode = 'PDM10' then v_status := 'Completed - Suspended (reason: duplicate)';
             when v_appcode = 'FTP39' then v_status := 'Completed - Suspended (reason: flow)';
             else v_status := 'Completed - Sent';
        end case;

     else
        --transaction in queues
        select qt.name, q.label into v_qtypeName, v_qlabel
        from fincfg.queues q join fincfg.queuetypes qt on q.queuetypeid = qt.id
        where q.id = v_queueId;
        
        case when v_qtypeName = 'Authorization' then v_status := 'Waiting for Authorization';
             when v_qtypeName = 'Business Investigation' then v_status := 'Waiting for Business Investigation';
             when v_qtypeName = 'Technical Investigation' then v_status := 'Waiting for Technical Investigation';
             when v_qtypeName = 'Duplicates Investigation' then v_status := 'Waiting for Duplicates Investigation';
             else v_status := 'In Process';
        end case;
      
        v_status := v_status||'~~'||v_qlabel;

      end if;
      
RETURN v_status;
  
EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering original message. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.getstatus(incorrelid character varying) OWNER TO findata;

--
-- TOC entry 405 (class 1255 OID 62618)
-- Name: getstmpayments(character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, numeric, numeric, numeric, numeric, character varying, character varying, character varying, character varying, integer, character varying, character varying, character varying, integer, integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.getstmpayments(insdatemin character varying, insdatemax character varying, inmsgtype character varying, insender character varying, inreceiver character varying, instmtref character varying, inobdate character varying, incbdate character varying, inobamountmin numeric, inobamountmax numeric, incbamountmin numeric, incbamountmax numeric, inccy character varying, inaccnumber character varying, indirect character varying, instate character varying, inuserid integer, inqname character varying, inordfield character varying, inorddir character varying, inllimit integer, inulimit integer, OUT outretcursor refcursor) RETURNS refcursor
    LANGUAGE plpgsql
    AS $_$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  05.Jun.2015, CRaluca 8817
  Created:         30.Jun.2014, DenisaN 8461
  Description:    Gathers data for the Funds Transfer reporting according to the given filtering     
  Parameters:     insdatemin - low date interval value
                  insdatemax - high date interval value
                  inmsgtype  - message type
                  insender   - sender BIC
                  inreceiver - receiver BIC 
                  instmtref  - stmt reference    
                  inobdate   - ob date  
                  incbdate   - cb date   
                  inobamountmin - low amount interval value
                  inobamountmax - high amount interval value
                  incbamountmin - low amount interval value
                  incbamountmax - high amount interval value
                  inccy         - currency
                  inaccnumber  - account number  
                  indirect   - I/O direction
                  instate    - tx state
                  inuserid   - user identifier
                  inqname    - queue name
                  inordfield - order by field
                  inorddir   - order by direction 
                  inllimit   - low limit / msg per page
                  inulimit   - upper limit / msg per page                          
  Returns:        cursor
  Used:           FinTP/BASE/UI Statements
***********************************************/

BEGIN


open outretcursor for execute
'select * from ('||
 ' select tmp.*, max(tmp.rnum) over() rnummax'||
 ' from ( '||
 ' select  row_number() over (order by '||coalesce(inordfield, 'receiver ')||' '||coalesce(inorddir, 'asc')||' ) rnum, '||   
         ' messagetype, sender, receiver, currency, accountnumber, openbalancemark||openbalanceamount ibalance, '||
         ' closebalancemark||closebalanceamount fbalance, openbalancedate, closebalancedate, statementuid, statementref, stmtnumber, '||
         ' direction, max(case when errorcode is null then state '||
                         ' else state||'' [''||errorcode||'']'' '||
                    ' end) state, max(userid) userid, queuename ' ||
  ' from findata.repstatstm '||
  ' where insertdate >= to_timestamp($1,''dd mm yyyy hh24:mi:ss'') and insertdate <= to_timestamp($2,''dd mm yyyy hh24:mi:ss'') '||
       ' and  ( $3 is null or  messagetype = $4 )'||
       ' and  ( $5 is null or lower(sender) = lower($6) ) '||       
       ' and  ( $7 is null or lower(receiver) = lower($8) ) '|| 
       ' and ( $9 is null or currency = $10 ) ' ||
       ' and ( $11 is null or lower(accountnumber) like lower(''%''||$12||''%'')) ' ||
       ' and ( (openbalanceamount >= coalesce($13,0) and openbalanceamount <= coalesce($14,99999999999999999999) ) )'||
       ' and ( (closebalanceamount >= coalesce($15,0) and closebalanceamount <= coalesce($16,99999999999999999999) ) )'||
       ' and  ( $17 is null or openbalancedate = $18) ' ||      
       ' and  ( $19 is null or closebalancedate = $20) ' ||      
       ' and  ( $21 is null or lower(statementref) like lower(''%''||$22||''%'')) '||
       ' and ( $23 is null or direction = $24) ' ||
       ' and ( $25 is null or state = $26) ' ||
       ' and ( $27 is null or userid = $28 ) ' ||
      ' and ( $29 is null or lower(queuename) = lower($30)) ' ||
   ' group by messagetype, sender, receiver, currency, accountnumber, openbalancemark||openbalanceamount, '||
              'closebalancemark||closebalanceamount, openbalancedate, closebalancedate, statementuid, stmtref, stmtnumber, '||
             ' direction, queuename'||           
   ' order by '||coalesce(inordfield, 'receiver')||' '||coalesce(inorddir, 'asc')||') tmp ) tmp1'||
   ' where rnum > coalesce($31,0) and rnum <= coalesce($32,100)+ coalesce($33,0)'
using insdatemin, insdatemax, inmsgtype, inmsgtype, insender, insender, inreceiver, inreceiver, 
      inccy, inccy, inaccnumber, inaccnumber, inobamountmin, inobamountmax, incbamountmin, incbamountmax,
      inobdate, inobdate, incbdate, incbdate, instmtref, instmtref, 
      indirect, indirect, instate, instate, inuserid, inuserid, inqname, inqname, inllimit, inulimit, inllimit;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while gathering messages. Message is: %', SQLERRM;
       
END;
$_$;


ALTER FUNCTION findata.getstmpayments(insdatemin character varying, insdatemax character varying, inmsgtype character varying, insender character varying, inreceiver character varying, instmtref character varying, inobdate character varying, incbdate character varying, inobamountmin numeric, inobamountmax numeric, incbamountmin numeric, incbamountmax numeric, inccy character varying, inaccnumber character varying, indirect character varying, instate character varying, inuserid integer, inqname character varying, inordfield character varying, inorddir character varying, inllimit integer, inulimit integer, OUT outretcursor refcursor) OWNER TO findata;

--
-- TOC entry 455 (class 1255 OID 62622)
-- Name: insertevent(character varying, integer, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, character varying, integer, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.insertevent(inguid character varying, inservice integer, incorrelid character varying, insession character varying, inevtype character varying, inmachine character varying, inevdate character varying, inmessage character varying, inclass character varying, inaddinfo character varying, ininnerex character varying, inuserid integer, inroutingpoint character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
8.Dec.2020, dd 14522                   
17.May.2016, DenisaN sync
  Created:         17.May.2013, DenisaN  7164
  Description:     Auditing one event. 
  Parameters:   inGuid         - generated identifier
	        inService      - audited service
	        inCorrelID     - message correlation identifier
	        inSession      - session identifier
	        inEvType       - Info, Warning, Error
	        inMachine      - host machine
	        inEvDate       - event date [format: "YYYY-MM-DD-HH24.MI.SS"]
	        inMessage      - event text
	        inClass        - [not used] 
	        inAddInfo      - event additional info 
	        inInnerEx      - related subevents
  Returns:      n/a
  Used:         FinTP/BASE/RE/Conn
***********************************************/   

BEGIN

   insert into findata.status ( guid, service,  sessionid, correlationid,  additionalinfo, type, class,  machine, 
                        eventdate,  insertdate,  message, innerexception, userid )
               values ( inGuid, inService, inSession, inCorrelID, inAddinfo, inEvtype, inClass, inMachine,
                        to_timestamp( inEvDate, 'YYYY-MM-DD-HH24.MI.SS' ), now(), inMessage, inInnerex, inuserid);

EXCEPTION
  WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while auditing: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.insertevent(inguid character varying, inservice integer, incorrelid character varying, insession character varying, inevtype character varying, inmachine character varying, inevdate character varying, inmessage character varying, inclass character varying, inaddinfo character varying, ininnerex character varying, inuserid integer, inroutingpoint character varying) OWNER TO findata;

--
-- TOC entry 395 (class 1255 OID 62623)
-- Name: inserthash(character varying, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.inserthash(inservicename character varying, inmessageid character varying, inhash character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         06.Feb.2014, DenisaN 8192
  Description:     Inserts hashes for every given message 
  Parameters:      inServiceID  - service identifier
                   inMessageID  - message identifier
                   inHash       - message hash          
  Returns:         n/a
  Used:            FinTP/2D/RE
***********************************************/

BEGIN


    insert into findata.messagehashes (servicename, routedmessageid, hash, insertdate, receivingorder)
                                      (select  inServiceName, inMessageID, inHash, now(), count(inServiceName) + 1 from findata.messagehashes 
                                                           where servicename = inServiceName and hash = inHash );
      
EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while storing message hash: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.inserthash(inservicename character varying, inmessageid character varying, inhash character varying) OWNER TO findata;

--
-- TOC entry 408 (class 1255 OID 62625)
-- Name: insertincomingbatch(character varying, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.insertincomingbatch(inbatchid character varying, inmessageid character varying, innamespace character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
                   03.Jun.2014, DenisaN - 8428 
  Created:         27.Mar.2013, DenisaN
  Description:     Recording incoming batch info. 
  Parameters:      inBatchID  - batch identifier
                   inMessageID  - message identifier
                   inNamespace - batch namespace
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/ 


v_Sender varchar(12);

BEGIN

  select sender into v_Sender from findata.routedmessages where id = inMessageID;

  insert into findata.batchjobsinc  (sender, batchid, batchtype, insertdate)
                             values (v_Sender, inBatchID, inNamespace, now());
                                                                        
      
EXCEPTION
WHEN  unique_violation THEN
    null;
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing batch: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.insertincomingbatch(inbatchid character varying, inmessageid character varying, innamespace character varying) OWNER TO findata;

--
-- TOC entry 409 (class 1255 OID 62626)
-- Name: insertmessage(character varying, character varying, character varying, character varying, character varying, character varying[], character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.insertmessage(inmsgtype character varying, insenderapp character varying, inreceiverapp character varying, inguid character varying, incorrelid character varying, inkwnames character varying[], inentity character varying) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  28.Oct.2021, dd - 16172
                   31.Aug.2018, DanielC - 12963
  				   14.Jun.2018, DanielC - 12880
                   11.Jun.2018, DanielC - 12857
                   23.May.2018, DanielC - 12835
                   03.Feb.2014, DenisaN - date format
  Created:         20.May.2013, DenisaN - 7164
  Description:     Inserts every routed message into common table and specific tables.  
  Parameters:    inMsgType       - message type to be inserted
		         inSenderApp     - sender application service
                 inGuid          - unique identifier
		         inCorrelID      - correlation identifier  
		         inKWNames       - message keywords [see cfg.routingkeywordmapps] followed by their values
  Returns:       n/a
  Used:          FinTP/BASE/RE
***********************************************/

v_ReferenceIdx     integer default 0;
v_SenderIdx        integer default 0;
v_ReceiverIdx      integer default 0;
v_AmountIdx        integer default 0;
v_tablename        varchar(35);
v_insertfields     varchar(2000) default '(';
v_insertvalues     varchar(2000) default '(';
v_half             integer;
--v_kwvalues         varchar[];
v_dateformat       varchar(6);
v_ioidentifier     varchar(1);

BEGIN

     v_half := array_length(inKWNames,1)/2;
     
     for i in 1..v_half loop
            
            case  
                     --extract message common info  and ammount
                      when inKWNames[i] = 'Reference' then v_ReferenceIdx := i;
                      when inKWNames[i] = 'Sender' then v_SenderIdx := i;
                      when inKWNames[i] = 'Receiver' then v_ReceiverIdx := i;
                      --when inKWNames[i] = 'Amount' then v_AmountIdx:=i;
                      
            else 
                      --extract message specific info
                      v_insertfields := v_insertfields||inKWNames[i];

                     if inKWNames[i + v_half] is null then 
					    v_insertvalues := v_insertvalues||''''||'null'||'''';
					    
					  --standard date format
					 elsif lower(inKWNames[i]) like '%date' then                          
                        select findata.getbusinessdateformat(inKWNames[i + v_half]) into v_dateformat;  
                        v_insertvalues := v_insertvalues||''''||v_dateformat||'''';
                          
                     else
       				    v_insertvalues := v_insertvalues||' E'||''''||replace(inKWNames[i + v_half],'''','\''')||'''';
                                           				    
                     end if;

                                 
                     v_insertfields := v_insertfields||',';
                     v_insertvalues := v_insertvalues||','; 
            end case; 
     end loop;  

    --retrieve specific message table storage                                           
    select distinct storage into  v_tablename from fincfg.messagetypes where messagetype =  inMsgType; 
   
   select ioidentifier into v_ioidentifier from findata.entryqueue where correlationid = incorrelid;  

   --insert message info into storage tables    
   insert into findata.routedmessages (currentqueue, id, correlationid, messagetype, sender, receiver, reference, requestorservice, responderservice, entity, ioidentifier) 
                               values (fincfg.getqueueid(insenderapp||'Queue'), inGuid, inCorrelID, inMsgType, inKWNames[v_SenderIdx+v_half], inKWNames[v_ReceiverIdx+v_half], inKWNames[v_ReferenceIdx+v_half], inSenderApp, inReceiverApp, inentity, v_ioidentifier);                                                                       
 execute 'insert into findata.'||v_tablename||' '||v_insertfields||' correlationid, messagetype) values '||v_insertvalues||' $1, $2 )'using inCorrelID, inMsgType;
	

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while inserting message: %', SQLERRM;
       
END;
$_$;


ALTER FUNCTION findata.insertmessage(inmsgtype character varying, insenderapp character varying, inreceiverapp character varying, inguid character varying, incorrelid character varying, inkwnames character varying[], inentity character varying) OWNER TO findata;

--
-- TOC entry 410 (class 1255 OID 62629)
-- Name: insertmessageinqueue(character varying, text, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.insertmessageinqueue(inguid character varying, inpayload text, inbatchid character varying, incorrelid character varying, insessid character varying, inreqservice character varying, inrespservice character varying, inreqtype character varying, inpriority integer, inholdstatus integer, insequence integer, infeedback character varying, inqueuename character varying, inioidentifier character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
                       27.May.2014, DenisaN         
  Created:             09.Aug.2013, LucianP 7698
  Description:         Inserts a message into one given queue (as entry queue)
  Parameters:                      inGuid - message identifier
                                   inPayload  - message payload
                                   inBatchID  - batch identifier
                                   inCorrelID  - correlation identifier
                                   inReqService  - requestor service
                                   inRespService   - responder service
                                   inReqType  - request type
                                   inPriority   - processing priority
                                   inHoldstatus  - hold status 1/0
                                   inSequence - routing rule sequence
                                   inFeedback  - message feedback
                                   inSessID - session identifier                    
                                  inQueueName -  destination queue name
                                  inIOIdentifier -  I/O/U (incoming/outgoing/undefined)
  Returns:              n/a
  Used:                 FinTP/BASE/RE
***********************************************/

BEGIN

    insert into findata.entryqueue (id, payload, batchid, correlationid, requestorservice, responderservice, requesttype, priority, holdstatus, sequence, feedback, sessionid, queuename, ioidentifier)
       values (inGuid, inPayload, inBatchID, inCorrelID, inReqService, inRespService, inReqType, inPriority, inHoldstatus, inSequence, inFeedback, inSessID, inQueueName, inIOIdentifier);
    update findata.routedmessages set currentqueue = fincfg.getqueueid(inqueuename) where correlationid =  inCorrelID;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while inserting message. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.insertmessageinqueue(inguid character varying, inpayload text, inbatchid character varying, incorrelid character varying, insessid character varying, inreqservice character varying, inrespservice character varying, inreqtype character varying, inpriority integer, inholdstatus integer, insequence integer, infeedback character varying, inqueuename character varying, inioidentifier character varying) OWNER TO findata;

--
-- TOC entry 420 (class 1255 OID 96979)
-- Name: loadqpcms(character varying, text, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.loadqpcms(inhash character varying, inmessage text, intablename character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  05.Jun.2018, DanielC - 12857
  				   22.May.2018, DanielC - 12835
                   06.Feb.2014, DenisaN - 8192               
  Created:     12.Mar.2013, DenisaN - 7164  
  Description: Extracting and routing message to entry queue (+ history);
  Parameters: inHash  - message computed hash value
              inMessage  - xml format message
              inTableName   - message entry queue
              inBufferSize  - 
  Returns:    outResultCode, outResultMessage 
  Used:       FinTP/BASE/Conn
***********************************************/             

  v_XMLData                  xml;
  v_PayloadOrg               text;
  v_PayloadTrf               text;
  v_Guid                     varchar(30);
  v_BatchId                  varchar(35);
  v_CorrelId                 varchar(30);
  v_SessionId                varchar(30);
  v_RequestorService         varchar(30);
  v_Hash                     varchar(50);
  v_ResponderService         varchar(30);
  v_RequestType              varchar(30);
  v_Feedback                 varchar(40);
  v_priority                 integer;
  v_IOIdentifier			 varchar(1);

BEGIN

select xmlparse(DOCUMENT inMessage) into v_XMLData;

select (xpath('/qPCMessageSchema/Message/Payload/Original/text()', v_XMLData))[1]::varchar into v_PayloadOrg;
select (xpath('/qPCMessageSchema/Message/Payload/Transformed/text()', v_XMLData))[1]::varchar into v_PayloadTrf;
select (xpath('/qPCMessageSchema/Message/Guid/text()', v_XMLData))[1]::varchar into v_Guid;
select (xpath('/qPCMessageSchema/Message/BatchId/text()', v_XMLData))[1]::varchar into v_BatchId; --nullable
select (xpath('/qPCMessageSchema/Message/CorrelationId/text()', v_XMLData))[1]::varchar into v_CorrelId;
select (xpath('/qPCMessageSchema/Message/SessionId/text()', v_XMLData))[1]::varchar into v_SessionId;
select (xpath('/qPCMessageSchema/Message/RequestorService/text()', v_XMLData))[1]::varchar into v_RequestorService;
select (xpath('/qPCMessageSchema/Message/ResponderService/text()', v_XMLData))[1]::varchar into v_ResponderService; --nullable
select (xpath('/qPCMessageSchema/Message/RequestType/text()', v_XMLData))[1]::varchar into v_RequestType;
select (xpath('/qPCMessageSchema/Message/Feedback/text()', v_XMLData))[1]::varchar into v_Feedback;
select (xpath('/qPCMessageSchema/Message/IOIdentifier/text()', v_XMLData))[1]::varchar into v_IOIdentifier;


  if inHash is not null and inHash !=''  then
    perform findata.inserthash(v_RequestorService, v_Guid, inHash);
  else
    select (xpath('/qPCMessageSchema/Message/Hash/text()', v_XMLData))[1]::varchar into v_Hash;
    if v_Hash is not null and inHash !='' then 
        perform findata.inserthash(v_RequestorService, v_Guid, v_Hash); 
    end if;
  end if; 

insert into findata.history (id, payload, batchid, correlationid, sessionid, requestorservice, responderservice, requesttype, feedback, insertdate)
                     values (v_Guid, v_PayloadOrg, v_BatchId, v_CorrelId, v_SessionId, v_RequestorService, v_ResponderService, v_RequestType, v_Feedback, current_timestamp);

select priority into v_priority from fincfg.queues where name = inTableName;
insert into findata.entryqueue (id, payload, batchid, correlationid, sessionid, requestorservice, responderservice, requesttype, feedback, queuename, priority, ioidentifier ) 
                        values (v_Guid, v_PayloadTrf, v_BatchId, v_CorrelId, v_SessionId, v_RequestorService, v_ResponderService, v_RequestType, v_Feedback, inTableName, v_priority, v_IOIdentifier);


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing message: %', SQLERRM;

END;
$$;


ALTER FUNCTION findata.loadqpcms(inhash character varying, inmessage text, intablename character varying) OWNER TO findata;

--
-- TOC entry 411 (class 1255 OID 62635)
-- Name: modifymessageinqueue(character varying, text, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.modifymessageinqueue(inguid character varying, inpayload text, inbatchid character varying, incorrelid character varying, insessid character varying, inreqservice character varying, inrespservice character varying, inreqtype character varying, inpriority integer, inholdstatus integer, insequence integer, infeedback character varying, intoqueuename character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:             09.Aug.2013, LucianP 7698
  Description:         Updates message specific information for a message in queue, along with changing the source queue name.
  Parameters:          inGuid - message identifier
                       inPayload  - message payload
                       inBatchID  - batch identifier
                       inCorrelID  - correlation identifier
                       inReqService  - requestor service
                       inRespService   - responder service
                       inReqType  - request type
                       inPriority   - processing priority
                       inHoldstatus  - hold status 1/0
                       inSequence - routing rule sequence
                       inFeedback  - message feedback
                       inSessID - session identifier 
                       inToQueueName - destination queue name                                    
  Returns:             n/a
  Used:                FinTP/BASE/RE
***********************************************/

BEGIN

    perform findata.updatemessageinqueue(inGuid,  inPayload, inBatchID,  inCorrelID, inSessID, inReqService,  inRespService, inReqType,  inPriority,  inHoldstatus,  inSequence,  inFeedback);
    perform findata.movemessageinqueue(inGuid,  inTOQueueName,  '');  
    update findata.routedmessages set currentqueue = fincfg.getqueueid(intoqueuename) where correlationid = incorrelid;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while modifying message. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.modifymessageinqueue(inguid character varying, inpayload text, inbatchid character varying, incorrelid character varying, insessid character varying, inreqservice character varying, inrespservice character varying, inreqtype character varying, inpriority integer, inholdstatus integer, insequence integer, infeedback character varying, intoqueuename character varying) OWNER TO findata;

--
-- TOC entry 412 (class 1255 OID 62638)
-- Name: movemessageinqueue(character varying, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.movemessageinqueue(inguid character varying, intoqueuename character varying, infromqueuename character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
                                    09.Aug.2013, LucianP 7698
  Created:            09.Aug..2013, LucianP 7163
  Description:        Changes source queue for one given messages [virtually moving one message to other queue]
  Parameters:         inGuid - message identifier
                      inTOQueueName -  destination queue name
                      inFROMQueueName - current queue name [not used]                                      
  Returns:            n/a
  Used:               FinTP/BASE/RE
***********************************************/

BEGIN

       update findata.entryqueue set queuename = inTOQueueName, sequence = 0 where id = inGuid;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while moving message. Message is:%', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.movemessageinqueue(inguid character varying, intoqueuename character varying, infromqueuename character varying) OWNER TO findata;

--
-- TOC entry 413 (class 1255 OID 62639)
-- Name: purgehashes(integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.purgehashes(inint integer) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
                   14.Jan.2020, dd - 14485
  Created:         06.Feb.2014, DenisaN - 8192
  Description:     Maintaining the duplicate detection time window
  Parameters:      n/a
  Returns:         n/a
  Used:            FinTP/2D/RE
***********************************************/

v_date             date;
v_count            integer;
v_periodpymt        integer;
v_periodstmt        integer;
v_periodinvc        integer;

BEGIN
        
    select to_number(value, '99999') into v_periodpymt from fincfg.params where code = 'DDPYMT'; 
    select to_number(value, '99999') into v_periodstmt from fincfg.params where code = 'DDSTMT'; 
    select to_number(value, '99999') into v_periodinvc from fincfg.params where code = 'DDINVC'; 

    
    v_date := fincfg.getlastbusinessday(current_date, v_periodpymt);
     --TO BE ARCHIVED
     delete from findata.messagehashes where insertdate  < v_date and routedmessageid in (select id from findata.repstatpymt);

     v_date := fincfg.getlastbusinessday(current_date, v_periodstmt);
     --TO BE ARCHIVED
     delete from findata.messagehashes where insertdate  < v_date and routedmessageid in (select id from findata.repstatstmt);

     v_date := fincfg.getlastbusinessday(current_date, v_periodinvc);
     --TO BE ARCHIVED
     delete from findata.messagehashes where insertdate  < v_date and routedmessageid in (select id from findata.repstatinvc);


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while purging hashes: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.purgehashes(inint integer) OWNER TO findata;

CREATE FUNCTION findata.readmessageinqueue(OUT outretcursor refcursor, inguid character varying, inqueuename character varying) RETURNS refcursor
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         20.Aug.2013, LucianP 7164
  Description:     Extract data for one given message in queue
  Parameters:      inGuid - message identifier
                   inQueueName - current queue name [not used]                                  
  Returns:         outRetCursor parameter representing cursor result set
  Used:            FinTP/BASE/RE
***********************************************/

BEGIN  

open outRetCursor for  
    select id, payload, batchid, correlationid, sessionid, requestorservice, responderservice, requesttype,	
           priority, holdstatus, sequence, feedback, ioidentifier
    from findata.entryqueue where id = inGuid and queuename = inQueueName;	
  
EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while reading queue: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.readmessageinqueue(OUT outretcursor refcursor, inguid character varying, inqueuename character varying) OWNER TO findata;

--
-- TOC entry 415 (class 1255 OID 62644)
-- Name: resumejobs(integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.resumejobs(instatus integer) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         20.May.2013, DenisaN 7164
  Description:     Marks routing jobs as new
  Parameters:      inStatus - old status
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/       

BEGIN

    update  findata.routingjobs set status = 0 where status = inStatus;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing job: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.resumejobs(instatus integer) OWNER TO findata;

--
-- TOC entry 417 (class 1255 OID 62645)
-- Name: rollbackjob(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.rollbackjob(injobid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         20.May.2013, DenisaN 7164
  Description:     Updates status and backout for one given routing job 
  Parameters:      inJobID - routing job identifier
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/       

BEGIN
   
   update routingjobs set backout = backout + 1, status = 0 where id = inJobID;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while moving message: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.rollbackjob(injobid character varying) OWNER TO findata;

--
-- TOC entry 419 (class 1255 OID 62651)
-- Name: terminatebatch(character varying, character varying, integer, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.terminatebatch(incombatchid character varying, inbatchtype character varying, instatus integer, inreason character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         21.Aug.2013, LucianP
  Description:     Marks batch final status and remove temporary related data.
  Parameters:      inCombatchID - batch identifier
                   inBatchType - batch type
                   inStatus  - batch state      
                   inReason - reason of failure
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/   


BEGIN

  update findata.batchjobs set status = inStatus, reason = substr(inReason, 1, 499 ), batchtype = inBatchType
          where batchid = inCombatchID;
   
  delete from findata.tempbatchjobs where batchid = inCombatchID;

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing batch. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.terminatebatch(incombatchid character varying, inbatchtype character varying, instatus integer, inreason character varying) OWNER TO findata;

--
-- TOC entry 400 (class 1255 OID 62654)
-- Name: trg_insertroutingjob(); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.trg_insertroutingjob() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
	insert into findata.routingjobs( id, status, backout, priority, routingpoint, function, userid )
                                 values( new.id, 0, 0, new.priority, new.queuename, 'F=Route', null );

    RETURN NULL; 
END;
$$;


ALTER FUNCTION findata.trg_insertroutingjob() OWNER TO findata;

--
-- TOC entry 360 (class 1255 OID 101647)
-- Name: trg_saveprocjob(); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.trg_saveprocjob() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN 
	insert into fintrack.routingjobsstmint( id, status, backout, priority, routingpoint, function, userid )
    values( old.id, old.status, old.backout, old.priority, old.routingpoint, old.function, old.userid );
    RETURN OLD; 
END;

$$;


ALTER FUNCTION findata.trg_saveprocjob() OWNER TO findata;

--
-- TOC entry 460 (class 1255 OID 2022570)
-- Name: trg_saverepbsdatajob(); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.trg_saverepbsdatajob() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN 
	update findata.repbalancesheet set ( id,entity, year, omfp1, omfp2, omfp3, omfp5, omfp8, omfp9, omfp10, omfp11, omfp12, omfp31, omfp39, omfp45, omfp46, omfp47, omfp43, omfp44, omfp48, omfp18, omfp19, omfp20, omfp15, totalact, totalactimob, totalcapstr, totalpas ) = ( new.id,new.entity, new.year, new.omfp1, new.omfp2, new.omfp3, new.omfp5, new.omfp8, new.omfp9, new.omfp10, new.omfp11, new.omfp12, new.omfp31, new.omfp39, new.omfp45, new.omfp46, new.omfp47, new.omfp43, new.omfp44, new.omfp48, new.omfp18, new.omfp19, new.omfp20, new.omfp15, new.omfp1 + new.omfp2 + new.omfp3 + new.omfp11 + new.omfp12, new.omfp1 + new.omfp2 + new.omfp3, new.omfp18 + new.omfp19 + new.omfp20 + new.omfp15, new.omfp48 + new.omfp18 + new.omfp19 + new.omfp20 + new.omfp15 ) where entity= new.entity and year = new.year;
	IF NOT FOUND THEN 
	insert into findata.repbalancesheet( id,entity, year, omfp1, omfp2, omfp3, omfp5, omfp8, omfp9, omfp10, omfp11, omfp12, omfp31, omfp39, omfp45, omfp46, omfp47, omfp43, omfp44, omfp48, omfp18, omfp19, omfp20, omfp15, totalact, totalactimob, totalcapstr, totalpas )
    values( new.id,new.entity, new.year, new.omfp1, new.omfp2, new.omfp3, new.omfp5, new.omfp8, new.omfp9, new.omfp10, new.omfp11, new.omfp12, new.omfp31, new.omfp39, new.omfp45, new.omfp46, new.omfp47, new.omfp43, new.omfp44, new.omfp48, new.omfp18, new.omfp19, new.omfp20, new.omfp15, new.omfp1 + new.omfp2 + new.omfp3 + new.omfp11 + new.omfp12, new.omfp1 + new.omfp2 + new.omfp3, new.omfp18 + new.omfp19 + new.omfp20 + new.omfp15, new.omfp48 + new.omfp18 + new.omfp19 + new.omfp20 + new.omfp15 );
	END IF; 
	RETURN NEW;
END;
$$;


ALTER FUNCTION findata.trg_saverepbsdatajob() OWNER TO findata;

--
-- TOC entry 461 (class 1255 OID 2022573)
-- Name: trg_savereppldatajob(); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.trg_savereppldatajob() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare

v_count integer;

BEGIN 
 
 
 if new.level = 'limited' then
 
 update findata.repprofitandloss set ( id,entity, year, omfp3, omfp2, omfp1, omfp8, omfp11, omfp12, omfp15, omfp16,
	                omfp17, omfp18, omfp19, omfp21, omfp24, omfp30, omfp40, omfp41, omfp42, omfp45, omfp48,
     omfp50, omfp54, omfp56, omfp57, omfp58, omfp59, omfp60, omfp61, omfp62, omfp63, omfp64, omfp67, omfp68 ) = 
     (new.id,new.entity, new.year, new.omfp3, new.omfp2, new.omfp1, new.omfp8, new.omfp11, new.omfp12, new.omfp15, 
     new.omfp16, new.omfp17, new.omfp18, new.omfp19, new.omfp21, new.omfp24, new.omfp30, new.omfp40, new.omfp41,
      new.omfp42, new.omfp45, new.omfp48, new.omfp50, new.omfp54, new.omfp56, new.omfp57, new.omfp58, new.omfp59,
       new.omfp60, new.omfp61, new.omfp62, new.omfp63, new.omfp64, new.omfp67, new.omfp68 )
   where entity = new.entity and year = new.year;
   
      select count(*) into v_count from findata.bsforecast 
     where (historicalbs = new.year or realisedbs = new.year) and entity = new.entity;
   if v_count > 0 then
      update findata.bsforecast set status = 'Outdated';
   end if;


 elsif new.level != 'limited' then
  
   update findata.repprofitandloss set ( id,entity, year, omfp3, omfp2, omfp1, omfp8, omfp11, omfp12, omfp15, omfp16,
	                omfp17, omfp18, omfp19, omfp21, omfp24, omfp30, omfp40, omfp41, omfp42, omfp45, omfp48,
     omfp50, omfp54, omfp56, omfp57, omfp58, omfp59, omfp60, omfp61, omfp62, omfp63, omfp64, omfp67, omfp68 ) = 
     (new.id,new.entity, new.year, new.omfp3, new.omfp2, new.omfp1, new.omfp8, new.omfp11, new.omfp12, new.omfp15, 
     new.omfp16, new.omfp17, new.omfp18, new.omfp19, new.omfp21, new.omfp24, new.omfp30, new.omfp40, new.omfp41,
      new.omfp42, new.omfp45, new.omfp48, new.omfp50, new.omfp54, new.omfp56, new.omfp57, new.omfp58, new.omfp59,
       new.omfp60, new.omfp61, new.omfp62, new.omfp63, new.omfp64, new.omfp67, new.omfp68 )
   where entity = new.entity and year = new.year;
   
   IF NOT FOUND THEN 
	insert into findata.repprofitandloss( id,entity, year, omfp3, omfp2, omfp1, omfp8, omfp11, omfp12, omfp15, omfp16,
	omfp17, omfp18, omfp19, omfp21, omfp24, omfp30, omfp40, omfp41, omfp42, omfp45, omfp48, omfp50, omfp54, omfp56, omfp57, omfp58, omfp59, omfp60, omfp61, omfp62, omfp63, omfp64, omfp67, omfp68 ) values( new.id,new.entity, new.year, new.omfp3, new.omfp2, new.omfp1, new.omfp8, new.omfp11, new.omfp12, new.omfp15, new.omfp16, new.omfp17, new.omfp18, new.omfp19, new.omfp21, new.omfp24, new.omfp30, new.omfp40, new.omfp41, new.omfp42, new.omfp45, new.omfp48, new.omfp50, new.omfp54, new.omfp56, new.omfp57, new.omfp58, new.omfp59, new.omfp60, new.omfp61, new.omfp62, new.omfp63, new.omfp64, new.omfp67, new.omfp68 );		
   END IF;

 
   select count(*) into v_count from findata.bsforecast 
     where (historicalbs = new.year or realisedbs = new.year) and entity = new.entity;
   if v_count > 0 then
      update findata.bsforecast set status = 'Outdated';
   end if;

 
 end if;

	RETURN NEW;
END;
$$;


ALTER FUNCTION findata.trg_savereppldatajob() OWNER TO findata;

--
-- TOC entry 421 (class 1255 OID 62655)
-- Name: updatecorridblobsqueue(character varying, character varying, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.updatecorridblobsqueue(inguid character varying, incorrelationid character varying, inbatchid character varying, inimageref character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         08.May.2014, DenisaN 8380
  Description:     Updates correlation id for exiting images 
  Parameters:      inGuid - transaction identifier
                   inCorrelationid - trasaction correlation identifier 
                   inBatchID - batch identifier  
                   inImageref - image reference number / same as trx
  Returns:       n/a
  Used:          FinTP/DI/CONN
***********************************************/   


BEGIN


update findata.blobsqueue set batchid = inGuid, correlationid = inCorrelationid 
                      where batchid = inBatchid and imagereference = inImageref;
       
                            
EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing message: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.updatemessageinqueue(inguid character varying, inpayload text, inbatchid character varying, incorrelid character varying, insessid character varying, inreqservice character varying, inrespservice character varying, inreqtype character varying, inpriority integer, inholdstatus integer, insequence integer, infeedback character varying) OWNER TO findata;

--
-- TOC entry 404 (class 1255 OID 95387)
-- Name: updatemessagetonewqueue(character varying, text, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.updatemessagetonewqueue(inguid character varying, inpayload text, inbatchid character varying, incorrelid character varying, insessid character varying, inreqservice character varying, inrespservice character varying, inreqtype character varying, inpriority integer, inholdstatus integer, insequence integer, infeedback character varying, intoqueuename character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
                       07.Apr.2021, dd
  Created:             09.Aug.2013, LucianP 7698
  Description:         Updates message specific information for a message in queue, along with changing the source queue name.
  Parameters:          inGuid - message identifier
                       inPayload  - message payload
                       inBatchID  - batch identifier
                       inCorrelID  - correlation identifier
                       inReqService  - requestor service
                       inRespService   - responder service
                       inReqType  - request type
                       inPriority   - processing priority
                       inHoldstatus  - hold status 1/0
                       inSequence - routing rule sequence
                       inFeedback  - message feedback
                       inSessID - session identifier 
                       inToQueueName - destination queue name                                    
  Returns:             n/a
  Used:                FinTP/BASE/RE
***********************************************/

BEGIN

    perform findata.updatemessageinqueue(inGuid,  inPayload, inBatchID,  inCorrelID, inSessID, inReqService,  inRespService, inReqType,  inPriority,  inHoldstatus,  inSequence,  inFeedback);
    perform findata.movemessageinqueue(inGuid,  inTOQueueName,  '');  
    update findata.routedmessages set currentqueue = fincfg.getqueueid(intoqueuename) where correlationid = incorrelid;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while modifying message. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.updatemessagetonewqueue(inguid character varying, inpayload text, inbatchid character varying, incorrelid character varying, insessid character varying, inreqservice character varying, inrespservice character varying, inreqtype character varying, inpriority integer, inholdstatus integer, insequence integer, infeedback character varying, intoqueuename character varying) OWNER TO findata;

--
-- TOC entry 403 (class 1255 OID 95368)
-- Name: updatemovemessageinqueue(character varying, text, character varying, character varying, character varying, character varying, character varying, character varying, integer, integer, integer, character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.updatemovemessageinqueue(inguid character varying, inpayload text, inbatchid character varying, incorrelid character varying, insessid character varying, inreqservice character varying, inrespservice character varying, inreqtype character varying, inpriority integer, inholdstatus integer, insequence integer, infeedback character varying, intoqueuename character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:             08.Oct.2018, dd
  Description:         Updates message specific information for a message in queue, along with changing the source queue name.
  Parameters:          inGuid - message identifier
                       inPayload  - message payload
                       inBatchID  - batch identifier
                       inCorrelID  - correlation identifier
                       inReqService  - requestor service
                       inRespService   - responder service
                       inReqType  - request type
                       inPriority   - processing priority
                       inHoldstatus  - hold status 1/0
                       inSequence - routing rule sequence
                       inFeedback  - message feedback
                       inSessID - session identifier 
                       inToQueueName - destination queue name                                    
  Returns:             n/a
  Used:                FinTP/BASE/RE
***********************************************/


BEGIN

    perform findata.updatemessageinqueue(inGuid,  inPayload, inBatchID,  inCorrelID, inSessID, inReqService,  inRespService, inReqType,  inPriority,  inHoldstatus,  inSequence,  inFeedback);
    perform findata.movemessageinqueue(inGuid,  inTOQueueName,  '');  
    update findata.routedmessages set currentqueue = fincfg.getqueueid(intoqueuename) where correlationid = incorrelid;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while modifying message. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.updatemovemessageinqueue(inguid character varying, inpayload text, inbatchid character varying, incorrelid character varying, insessid character varying, inreqservice character varying, inrespservice character varying, inreqtype character varying, inpriority integer, inholdstatus integer, insequence integer, infeedback character varying, intoqueuename character varying) OWNER TO findata;

--
-- TOC entry 423 (class 1255 OID 62657)
-- Name: updaterefusalfbcode(character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.updaterefusalfbcode(inbatchid character varying, incode character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  11.Jun.2018, DanielC 12857                                    
  Created:         14.Feb.2014  --  DenisaN
  Description:     Updates Correspondent/Network codes of original msg when refusal received
  Parameters:      inBatchid   - refusal batch identifier
                   inCode - refusal code
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/   

v_origBatchID         varchar(35);
v_origRef             varchar(30);
v_amount              numeric(17, 2);
v_storage             varchar(35);
v_msgtype             varchar(35);

--all the refusals in one batch
v_cursor cursor( v_batchid varchar) for
   select correlationid from findata.feedbackagg where batchid = v_batchid;

BEGIN

       --get original message type and storage
     select distinct messagetype into v_msgtype from findata.routedmessages 
            where correlationid = (select correlationid from findata.feedbackagg where batchid = inBatchID);
     select storage into v_storage from fincfg.msgtypes where messagetype =  v_msgtype;                  

if v_msgtype in ('RCQ', 'RPN', 'RBE') then

     for rec in v_cursor (inBatchID) loop                

        execute ' select originalbatchid, origreference, to_number(case  when amount is null then ''0,00'' '|| 
                                                             ' when amount = '''' then ''0,00'' '|| 
                                                             ' when amount = '','' then ''0,00'' '|| 
                                                             ' else replace(amount, '','', ''.'') '|| 
                                                        ' end, ''FM99999999999999999D99'') '||                   
                ' from findata.'||v_storage||' where correlationid = '''||rec.correlid||'''' 
        into v_origBatchID, v_origRef, v_amount using rec.correlationid; 
            
        if v_amount = 0 then
           --mark total amount refusal
           update findata.feedbackagg set correspondentcode = inCode where batchid = v_origBatchID and reference = v_origRef;
        else
           --mark partial amount refusal
           update findata.feedbackagg set networkcode = inCode where batchid = v_origBatchID  and  reference = v_origRef;
        end if;            
                
     end loop;

else

   for rec in v_cursor (inBatchID) loop                

        execute ' select originalbatchid, originalref '||                   
                ' from findata.'||v_storage||' where correlationid = '''||rec.correlid||'''' 
        into v_origBatchID, v_origRef using rec.correlationid; 

       update findata.feedbackagg set correspondentcode = inCode where batchid = v_origBatchID and trn = v_origRef;
       
   end loop;
	

end if;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing message: %', SQLERRM;
       
END;
$$;

ALTER FUNCTION findata.updatermack(incorrelid character varying) OWNER TO findata;

--
-- TOC entry 425 (class 1255 OID 62661)
-- Name: updatermackbatch(character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.updatermackbatch(inbatchid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:   dd.mon.yyyy  --  author  --   description
  Created:          28.Aug.2013, LucianP
  Description:      Sets the number of replies to 1; used for transactions in one given batch 
  Parameters:       inBatchID   - batch identifier
  Returns:          n/a
  Used:             FinTP/BASE/RE
***********************************************/   

BEGIN

      update findata.routedmessages set ack = 1
                          where correlationid in (select correlationid from findata.feedbackagg where batchid = inBatchID);

EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing reply. Message is: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.updatermackbatch(inbatchid character varying) OWNER TO findata;

--
-- TOC entry 426 (class 1255 OID 62662)
-- Name: updatermassembleresponder(character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.updatermassembleresponder(inbatchid character varying, inreceiverapp character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         20.May.2013, DenisaN 7164
  Description:     Updates the receiver application for one given group of transactions, given its batchid
  Parameters:      inBatchID   - batch identifier
                   inReceiverApp - app receiver service
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/   

BEGIN

   update findata.routedmessages set requestorservice =   inReceiverApp  
                    where correlationid in ( select correlationid from findata.feedbackagg where batchid = inBatchid);


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing message: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.updatermassembleresponder(inbatchid character varying, inreceiverapp character varying) OWNER TO findata;

--
-- TOC entry 427 (class 1255 OID 62663)
-- Name: updatermresponder(character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.updatermresponder(incorrelid character varying, inreceiverapp character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         20.May.2013, DenisaN 7164
  Description:     Updates the receiver application for one given message
  Parameters:      inCorrelId   - correlation identifier
                   inReceiverApp - app receiver service
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/   

BEGIN

   update  findata.routedmessages set responderservice =  inReceiverApp  where correlationid = inCorrelId;


EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing message: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.updatermresponder(incorrelid character varying, inreceiverapp character varying) OWNER TO findata;

--
-- TOC entry 428 (class 1255 OID 62664)
-- Name: updatermuserid(character varying, integer); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.updatermuserid(incorrelationid character varying, inuserid integer) RETURNS void
    LANGUAGE plpgsql
    AS $$DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         20.May.2013, DenisaN 7164
  Description:     Updates the user identifier for one given message 
  Parameters:      inCorrelationID   - correlation identifier
                   inUserID - user identifier
  Returns:         n/a
  Used:            FinTP/BASE/RE
***********************************************/   

BEGIN

    update findata.routedmessages set userid = inUserID, updatedate = now() where  correlationid = inCorrelationID;



EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing message: %', SQLERRM;
       
END;
$$;


ALTER FUNCTION findata.updatermuserid(incorrelationid character varying, inuserid integer) OWNER TO findata;

--
-- TOC entry 429 (class 1255 OID 62665)
-- Name: updatermvaluedate(character varying, character varying); Type: FUNCTION; Schema: findata; Owner: findata
--

CREATE FUNCTION findata.updatermvaluedate(incorrelid character varying, invaluedate character varying) RETURNS void
    LANGUAGE plpgsql
    AS $_$
DECLARE

/*
* FinTP - Financial Transactions Processing Application
* Copyright (C) 2013 Business Information Systems (Allevo) S.R.L.
*
* This program is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* This program is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with this program. If not, see <http://www.gnu.org/licenses/>
* or contact Allevo at : 031281 Bucuresti, 23C Calea Vitan, Romania,
* phone +40212554577, office@allevo.ro <office@allevo.ro>, www.allevo.ro.
*/
/************************************************
  Change history:  dd.mon.yyyy  --  author  --   description
  Created:         20.May.2013, DenisaN 7164
  Description:     Updates the currency date for one given message 
  Parameters:      inCorrelID   - correlation identifier
                   inValueDate - message currency date
  Returns:       n/a
  Used:           FinTP/BASE/RE
***********************************************/   

v_tablename        varchar(35);
v_msgtype          varchar(35);

BEGIN
	select distinct storage, messagetype  into v_tablename, v_msgtype from fincfg.messagetypes where messagetype in 
		(select messagetype from findata.routedmessages where correlationid =  inCorrelID); 
	       
    if v_msgtype in ('CQ', 'PN', 'BE') then -- debit instruments  
        execute 'update findata.'||v_tablename||' set issuancedate = $1 where correlatinid = $2' using inValueDate, inCorrelID;
    else    
        execute 'update findata.'||v_tablename||' set valuedate = $1 where correlationid = $2' using inValueDate, inCorrelID;
    end if;
    
EXCEPTION
WHEN OTHERS THEN
   RAISE EXCEPTION 'Unexpected error occured while processing message: %', SQLERRM;
       
END;
$_$;


ALTER FUNCTION findata.updatermvaluedate(incorrelid character varying, invaluedate character varying) OWNER TO findata;

SET default_tablespace = '';

--
-- TOC entry 250 (class 1259 OID 62928)
-- Name: batchjobs; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.batchjobs (
    initialbatchid character varying(35) NOT NULL,
    userid integer NOT NULL,
    messagecount integer NOT NULL,
    amount character varying(20) NOT NULL,
    batchid character varying(35) NOT NULL,
    currentmessagecount integer NOT NULL,
    status integer NOT NULL,
    insertdate timestamp without time zone NOT NULL,
    routingpoint character varying(50) NOT NULL,
    reason character varying(500),
    finalamount numeric(20,2),
    batchtype character varying(50),
    batchuid character varying(32)
);


ALTER TABLE findata.batchjobs OWNER TO findata;

--
-- TOC entry 251 (class 1259 OID 62937)
-- Name: batchrequests; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.batchrequests (
    groupkey character varying(100),
    batchuid character varying(35),
    id integer DEFAULT nextval(('findata.batchrequests_requestid_seq'::text)::regclass) NOT NULL,
    userid integer
);


ALTER TABLE findata.batchrequests OWNER TO findata;

--
-- TOC entry 252 (class 1259 OID 62941)
-- Name: batchrequests_requestid_seq; Type: SEQUENCE; Schema: findata; Owner: findata
--

CREATE SEQUENCE findata.batchrequests_requestid_seq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 2147483647
    CACHE 1;


ALTER TABLE findata.batchrequests_requestid_seq OWNER TO findata;

SET default_tablespace = findatatbs;

--
-- TOC entry 341 (class 1259 OID 2031133)
-- Name: bsforecast; Type: TABLE; Schema: findata; Owner: findata; Tablespace: findatatbs
--

CREATE TABLE findata.bsforecast (
    id integer NOT NULL,
    realisedbs integer,
    forecast integer NOT NULL,
    historicalbs integer,
    omfp2 numeric(17,2),
    omfp3 numeric(17,2),
    omfp12 numeric(17,2),
    omfp16 numeric(17,2),
    omfp15 numeric(17,2),
    omfp21 numeric(17,2),
    omfp30 numeric(17,2),
    omfp40 numeric(17,2),
    omfp50 numeric(17,2),
    omfp57 numeric(17,2),
    omfp60 numeric(17,2),
    omfp61 numeric(17,2),
    omfp62 numeric(17,2),
    omfp63 numeric(17,2),
    omfp2f numeric(17,2),
    omfp3f numeric(17,2),
    omfp12f numeric(17,2),
    omfp16f numeric(17,2),
    omfp15f numeric(17,2),
    omfp21f numeric(17,2),
    omfp30f numeric(17,2),
    omfp40f numeric(17,2),
    omfp50f numeric(17,2),
    omfp57f numeric(17,2),
    omfp60f numeric(17,2),
    omfp61f numeric(17,2),
    omfp62f numeric(17,2),
    omfp63f numeric(17,2),
    entity character varying(100),
    userid integer,
    status character varying(200)
);


ALTER TABLE findata.bsforecast OWNER TO findata;

SET default_tablespace = '';

--
-- TOC entry 334 (class 1259 OID 2022574)
-- Name: plloadhistory; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.plloadhistory (
    source character varying(35) DEFAULT 'excel'::text,
    entity character varying(20) NOT NULL,
    username character varying(35),
    insertdate timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    year integer NOT NULL,
    omfp3 numeric(17,2) NOT NULL,
    omfp2 numeric(17,2) NOT NULL,
    omfp1 numeric(17,2),
    omfp8 numeric(17,2),
    omfp11 numeric(17,2),
    omfp12 numeric(17,2) NOT NULL,
    omfp15 numeric(17,2) NOT NULL,
    omfp16 numeric(17,2) NOT NULL,
    omfp17 numeric(17,2),
    omfp18 numeric(17,2),
    omfp19 numeric(17,2),
    omfp21 numeric(17,2) NOT NULL,
    omfp24 numeric(17,2),
    omfp30 numeric(17,2) NOT NULL,
    omfp40 numeric(17,2) NOT NULL,
    omfp41 numeric(17,2),
    omfp42 numeric(17,2),
    omfp45 numeric(17,2),
    omfp48 numeric(17,2),
    omfp50 numeric(17,2) NOT NULL,
    omfp54 numeric(17,2),
    omfp56 numeric(17,2),
    omfp57 numeric(17,2) NOT NULL,
    omfp58 numeric(17,2),
    omfp59 numeric(17,2),
    omfp60 numeric(17,2) NOT NULL,
    omfp61 numeric(17,2) NOT NULL,
    omfp62 numeric(17,2),
    omfp63 numeric(17,2),
    omfp64 numeric(17,2),
    omfp67 numeric(17,2),
    omfp68 numeric(17,2),
    id integer NOT NULL,
    level character varying(30)
);


ALTER TABLE findata.plloadhistory OWNER TO findata;

--
-- TOC entry 345 (class 1259 OID 2031180)
-- Name: bsforecastcomparison; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.bsforecastcomparison AS
 SELECT pl.omfp2,
    pl.omfp3,
    pl.omfp12,
    pl.omfp16,
    pl.omfp15,
    pl.omfp21,
    pl.omfp30,
    pl.omfp40,
    pl.omfp50,
    pl.omfp57,
    pl.omfp60,
    pl.omfp61,
    pl.omfp62,
    pl.omfp63,
    (pl.omfp2 * ((1)::numeric + (bsf.omfp2f / (100)::numeric))) AS omfp2f,
    (pl.omfp3 * ((1)::numeric + (bsf.omfp3f / (100)::numeric))) AS omfp3f,
    (pl.omfp12 * ((1)::numeric + (bsf.omfp12f / (100)::numeric))) AS omfp12f,
    (pl.omfp16 * ((1)::numeric + (bsf.omfp16f / (100)::numeric))) AS omfp16f,
    (pl.omfp15 * ((1)::numeric + (bsf.omfp15f / (100)::numeric))) AS omfp15f,
    (pl.omfp21 * ((1)::numeric + (bsf.omfp21f / (100)::numeric))) AS omfp21f,
    (pl.omfp30 * ((1)::numeric + (bsf.omfp30f / (100)::numeric))) AS omfp30f,
    (pl.omfp40 * ((1)::numeric + (bsf.omfp40f / (100)::numeric))) AS omfp40f,
    (pl.omfp50 * ((1)::numeric + (bsf.omfp50f / (100)::numeric))) AS omfp50f,
    (pl.omfp57 * ((1)::numeric + (bsf.omfp57f / (100)::numeric))) AS omfp57f,
    (pl.omfp60 * ((1)::numeric + (bsf.omfp60f / (100)::numeric))) AS omfp60f,
    (pl.omfp61 * ((1)::numeric + (bsf.omfp61f / (100)::numeric))) AS omfp61f,
    (pl.omfp62 * ((1)::numeric + (bsf.omfp62f / (100)::numeric))) AS omfp62f,
    (pl.omfp63 * ((1)::numeric + (bsf.omfp63f / (100)::numeric))) AS omfp63f,
    (pl.omfp2 - (pl.omfp2 * ((1)::numeric + (bsf.omfp2f / (100)::numeric)))) AS omfp2diff,
    (pl.omfp3 - (pl.omfp3 * ((1)::numeric + (bsf.omfp3f / (100)::numeric)))) AS omfp3diff,
    (pl.omfp12 - (pl.omfp12 * ((1)::numeric + (bsf.omfp12f / (100)::numeric)))) AS omfp12diff,
    (pl.omfp16 - (pl.omfp16 * ((1)::numeric + (bsf.omfp16f / (100)::numeric)))) AS omfp16diff,
    (pl.omfp15 - (pl.omfp15 * ((1)::numeric + (bsf.omfp15f / (100)::numeric)))) AS omfp15diff,
    (pl.omfp21 - (pl.omfp21 * ((1)::numeric + (bsf.omfp21f / (100)::numeric)))) AS omfp21diff,
    (pl.omfp30 - (pl.omfp30 * ((1)::numeric + (bsf.omfp30f / (100)::numeric)))) AS omfp30diff,
    (pl.omfp40 - (pl.omfp40 * ((1)::numeric + (bsf.omfp40f / (100)::numeric)))) AS omfp40diff,
    (pl.omfp50 - (pl.omfp50 * ((1)::numeric + (bsf.omfp50f / (100)::numeric)))) AS omfp50diff,
    (pl.omfp57 - (pl.omfp57 * ((1)::numeric + (bsf.omfp57f / (100)::numeric)))) AS omfp57diff,
    (pl.omfp60 - (pl.omfp60 * ((1)::numeric + (bsf.omfp60f / (100)::numeric)))) AS omfp60diff,
    (pl.omfp61 - (pl.omfp61 * ((1)::numeric + (bsf.omfp61f / (100)::numeric)))) AS omfp61diff,
    (pl.omfp62 - (pl.omfp62 * ((1)::numeric + (bsf.omfp62f / (100)::numeric)))) AS omfp62diff,
    (pl.omfp63 - (pl.omfp63 * ((1)::numeric + (bsf.omfp63f / (100)::numeric)))) AS omfp63diff,
    pl.entity,
    pl.year
   FROM (( SELECT plloadhistory.omfp2,
            plloadhistory.omfp3,
            plloadhistory.omfp12,
            plloadhistory.omfp16,
            plloadhistory.omfp15,
            plloadhistory.omfp21,
            plloadhistory.omfp30,
            plloadhistory.omfp40,
            plloadhistory.omfp50,
            plloadhistory.omfp57,
            plloadhistory.omfp60,
            plloadhistory.omfp61,
            plloadhistory.omfp62,
            plloadhistory.omfp63,
            plloadhistory.year,
            plloadhistory.entity
           FROM findata.plloadhistory) pl
     JOIN ( SELECT bsforecast.omfp2f,
            bsforecast.omfp3f,
            bsforecast.omfp12f,
            bsforecast.omfp16f,
            bsforecast.omfp15f,
            bsforecast.omfp21f,
            bsforecast.omfp30f,
            bsforecast.omfp40f,
            bsforecast.omfp50f,
            bsforecast.omfp57f,
            bsforecast.omfp60f,
            bsforecast.omfp61f,
            bsforecast.omfp62f,
            bsforecast.omfp63f,
            bsforecast.forecast,
            bsforecast.entity
           FROM findata.bsforecast) bsf ON (((pl.year = bsf.forecast) AND ((pl.entity)::text = (bsf.entity)::text))));


ALTER TABLE findata.bsforecastcomparison OWNER TO findata;

--
-- TOC entry 333 (class 1259 OID 2022561)
-- Name: bsloadhistory; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.bsloadhistory (
    source character varying(35) DEFAULT 'excel'::text,
    entity character varying(20) NOT NULL,
    username character varying(35),
    insertdate timestamp without time zone DEFAULT CURRENT_TIMESTAMP,
    year integer NOT NULL,
    omfp1 numeric(17,2) NOT NULL,
    omfp2 numeric(17,2) NOT NULL,
    omfp3 numeric(17,2) NOT NULL,
    omfp5 numeric(17,2) NOT NULL,
    omfp8 numeric(17,2) NOT NULL,
    omfp9 numeric(17,2) NOT NULL,
    omfp10 numeric(17,2) NOT NULL,
    omfp11 numeric(17,2) NOT NULL,
    omfp12 numeric(17,2) NOT NULL,
    omfp31 numeric(17,2) NOT NULL,
    omfp39 numeric(17,2) NOT NULL,
    omfp45 numeric(17,2),
    omfp46 numeric(17,2),
    omfp47 numeric(17,2) NOT NULL,
    omfp43 numeric(17,2),
    omfp44 numeric(17,2),
    omfp48 numeric(17,2) NOT NULL,
    omfp18 numeric(17,2) NOT NULL,
    omfp19 numeric(17,2) NOT NULL,
    omfp20 numeric(17,2) NOT NULL,
    omfp15 numeric(17,2) NOT NULL,
    id integer NOT NULL,
    CONSTRAINT ck_only_onec5 CHECK ((((omfp45 IS NULL) OR (omfp46 IS NULL)) AND (NOT ((omfp45 IS NULL) AND (omfp46 IS NULL))))),
    CONSTRAINT ck_only_onec6 CHECK ((((omfp43 IS NULL) OR (omfp44 IS NULL)) AND (NOT ((omfp43 IS NULL) AND (omfp44 IS NULL)))))
);


ALTER TABLE findata.bsloadhistory OWNER TO findata;

SET default_tablespace = findatatbs;

--
-- TOC entry 342 (class 1259 OID 2031140)
-- Name: cfcomparison; Type: TABLE; Schema: findata; Owner: findata; Tablespace: findatatbs
--

CREATE TABLE findata.cfcomparison (
    id integer NOT NULL,
    accountbalancedate date DEFAULT CURRENT_DATE,
    balanceiban character varying(35) NOT NULL,
    accountbalanceamount numeric(17,2) NOT NULL,
    accountbalancecurrency character varying(3) DEFAULT 'RON'::text,
    entity character varying(100),
    userid integer,
    exchangerate numeric(17,2),
    ronaccountbalanceamount numeric(17,2)
);


ALTER TABLE findata.cfcomparison OWNER TO findata;

--
-- TOC entry 343 (class 1259 OID 2031147)
-- Name: cfforecast; Type: TABLE; Schema: findata; Owner: findata; Tablespace: findatatbs
--

CREATE TABLE findata.cfforecast (
    id integer NOT NULL,
    operationtype character varying(100),
    opretionsubtype character varying(100),
    revenueexpensetype character varying(100),
    informationtype character varying(100),
    payersuppliername character varying(100),
    operationamount numeric(17,2) NOT NULL,
    operationcurrency character varying(3) DEFAULT 'RON'::text,
    issuedate date DEFAULT CURRENT_DATE,
    maturitydate date DEFAULT CURRENT_DATE,
    operationiban character varying(35) NOT NULL,
    entity character varying(100),
    userid integer,
    paymentduedate integer
);


ALTER TABLE findata.cfforecast OWNER TO findata;

--
-- TOC entry 344 (class 1259 OID 2031158)
-- Name: cfforecastgendata; Type: TABLE; Schema: findata; Owner: findata; Tablespace: findatatbs
--

CREATE TABLE findata.cfforecastgendata (
    id integer NOT NULL,
    indicator character varying(100),
    operationiban character varying(35),
    amt numeric(17,2),
    operationcurrency character varying(3) DEFAULT 'RON'::text,
    cfforecastdate date DEFAULT CURRENT_DATE,
    entity character varying(100)
);


ALTER TABLE findata.cfforecastgendata OWNER TO findata;

--
-- TOC entry 253 (class 1259 OID 62950)
-- Name: commbatchseq; Type: SEQUENCE; Schema: findata; Owner: findata
--

CREATE SEQUENCE findata.commbatchseq
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    MAXVALUE 9999
    CACHE 1;


ALTER TABLE findata.commbatchseq OWNER TO findata;

SET default_tablespace = '';

--
-- TOC entry 254 (class 1259 OID 62952)
-- Name: entryqueue; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.entryqueue (
    id character varying(30) NOT NULL,
    payload text NOT NULL,
    batchid character varying(35),
    correlationid character varying(30) NOT NULL,
    requestorservice character varying(30) NOT NULL,
    responderservice character varying(30),
    requesttype character varying(30) NOT NULL,
    priority integer DEFAULT 5,
    holdstatus integer DEFAULT 0 NOT NULL,
    sequence integer DEFAULT 0 NOT NULL,
    feedback character varying(40),
    sessionid character varying(30),
    status integer DEFAULT 1,
    queuename character varying(35),
    ioidentifier character(1) DEFAULT 'U'::bpchar NOT NULL
);


ALTER TABLE findata.entryqueue OWNER TO findata;

--
-- TOC entry 255 (class 1259 OID 62963)
-- Name: feedbackagg; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.feedbackagg (
    requestorservice character varying(50),
    mqid character varying(100),
    correlationid character varying(30),
    interfacecode character varying(10),
    networkcode character varying(10),
    correspondentcode character varying(10),
    applicationcode character varying(10),
    payload text,
    swiftmir character varying(30),
    insertdate timestamp without time zone DEFAULT now(),
    batchid character varying(35),
    batchsequence integer,
    reference character varying(35),
    osession character varying(10),
    isession character varying(10),
    issuer character varying,
    obatchid character varying(35),
    backofficecode character varying(10),
    externalid character varying(35),
    sourcefilename character varying(255),
    destinationfilename character varying(255),
    operationdetails character varying(140)
);


ALTER TABLE findata.feedbackagg OWNER TO findata;

--
-- TOC entry 256 (class 1259 OID 62970)
-- Name: history; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.history (
    id character varying(30) NOT NULL,
    payload text NOT NULL,
    batchid character varying(35),
    correlationid character varying(30) NOT NULL,
    sessionid character varying(30),
    requestorservice character varying(30) NOT NULL,
    responderservice character varying(30),
    requesttype character varying(30) NOT NULL,
    priority integer DEFAULT 5 NOT NULL,
    holdstatus integer DEFAULT 1 NOT NULL,
    sequence integer DEFAULT 0,
    insertdate timestamp without time zone,
    feedback character varying(40)
);


ALTER TABLE findata.history OWNER TO findata;

--
-- TOC entry 257 (class 1259 OID 62979)
-- Name: messagehashes; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.messagehashes (
    servicename character varying(35) NOT NULL,
    routedmessageid character varying(30) NOT NULL,
    hash character varying(32) NOT NULL,
    insertdate timestamp without time zone NOT NULL,
    receivingorder integer DEFAULT 1 NOT NULL
);


ALTER TABLE findata.messagehashes OWNER TO findata;

SET default_tablespace = findatatbs;

--
-- TOC entry 259 (class 1259 OID 63046)
-- Name: mtbktocstmrdbtcdttab; Type: TABLE; Schema: findata; Owner: findata; Tablespace: findatatbs
--

CREATE TABLE findata.mtbktocstmrdbtcdttab (
    correlationid character varying(30) NOT NULL,
    messagetype character varying(50) NOT NULL,
    valuedate character varying(6),
    amount character varying(50),
    currency character varying(3),
    accountnumber character varying(35) NOT NULL,
    statementnumber character varying(18),
    statementreference character varying(35) NOT NULL,
    openbalancedate character varying(6),
    closebalancedate character varying(6),
    trxmark character varying(5),
    name character varying(140),
    remittanceinfo character varying(500),
    CONSTRAINT ch_accno_notempty CHECK (((accountnumber)::text <> ''::text))
);


ALTER TABLE findata.mtbktocstmrdbtcdttab OWNER TO findata;

SET default_tablespace = '';

--
-- TOC entry 258 (class 1259 OID 62986)
-- Name: routedmessages; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.routedmessages (
    id character varying(30) NOT NULL,
    correlationid character varying(30),
    insertdate timestamp without time zone DEFAULT now(),
    ack integer DEFAULT 0,
    messagetype character varying(50),
    currentqueue integer,
    sender character varying(70),
    receiver character varying(70),
    reference character varying(35) NOT NULL,
    requestorservice character varying(35),
    responderservice character varying(35),
    userid integer,
    amount character varying(50),
    updatedate timestamp without time zone DEFAULT now(),
    entity character varying(35),
    ioidentifier character(1) DEFAULT 'U'::bpchar NOT NULL,
    paymentid character varying(50)
);


ALTER TABLE findata.routedmessages OWNER TO findata;

--
-- TOC entry 285 (class 1259 OID 172616)
-- Name: mtbktocstmrdbtcdtview; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.mtbktocstmrdbtcdtview AS
 SELECT eq.id,
    rm.messagetype,
    rm.sender,
    rm.receiver,
    rm.reference,
    rm.requestorservice,
    rm.insertdate,
    mt.accountnumber,
    mt.trxmark,
    mt.currency,
    mt.valuedate,
    to_number(
        CASE
            WHEN (rtrim((mt.amount)::text) IS NULL) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ''::text) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ','::text) THEN '0,00'::text
            ELSE replace(rtrim((mt.amount)::text), ','::text, '.'::text)
        END, 'FM99999999999999999D99'::text) AS amount,
    eq.queuename,
    eq.payload,
    rm.entity
   FROM ((( SELECT routedmessages.messagetype,
            routedmessages.sender,
            routedmessages.receiver,
            routedmessages.reference,
            routedmessages.correlationid,
            routedmessages.insertdate,
            routedmessages.requestorservice,
            routedmessages.entity
           FROM findata.routedmessages
          WHERE ((routedmessages.currentqueue IS NOT NULL) AND ((routedmessages.messagetype)::text = 'BkToCstmrDbtCdtNtfctn'::text))) rm
     LEFT JOIN ( SELECT mtbktocstmrdbtcdttab.correlationid,
            mtbktocstmrdbtcdttab.accountnumber,
            mtbktocstmrdbtcdttab.trxmark,
            mtbktocstmrdbtcdttab.currency,
            mtbktocstmrdbtcdttab.valuedate,
            mtbktocstmrdbtcdttab.amount
           FROM findata.mtbktocstmrdbtcdttab) mt ON (((rm.correlationid)::text = (mt.correlationid)::text)))
     LEFT JOIN ( SELECT entryqueue.id,
            entryqueue.correlationid,
            entryqueue.queuename,
            entryqueue.payload
           FROM findata.entryqueue) eq ON (((mt.correlationid)::text = (eq.correlationid)::text)));


ALTER TABLE findata.mtbktocstmrdbtcdtview OWNER TO findata;

--
-- TOC entry 260 (class 1259 OID 63057)
-- Name: mtcdttrfinitnothrtab; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.mtcdttrfinitnothrtab (
    correlationid character varying(30) NOT NULL,
    messagetype character varying(50),
    endtoendid character varying(35),
    dbtcustomername character varying(70),
    dbtaccount character varying(35),
    orderingbank character varying(12),
    amount character varying(50),
    currency character varying(3),
    valuedate character varying(6),
    accountingcode character varying(35),
    locationcode character varying(35),
    budgetcode character varying(35),
    cdtcustomername character varying(70),
    cdtaccount character varying(35),
    beneficiarybank character varying(12),
    remittanceinfo character varying(140)
);


ALTER TABLE findata.mtcdttrfinitnothrtab OWNER TO findata;

--
-- TOC entry 290 (class 1259 OID 173814)
-- Name: mtcdttrfinitnothrview; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.mtcdttrfinitnothrview AS
 SELECT eq.id,
    rm.messagetype,
    rm.sender,
    rm.receiver,
    rm.reference,
    rm.requestorservice,
    rm.insertdate,
    mt.orderingbank,
    mt.dbtaccount,
    mt.endtoendid,
    mt.cdtcustomername,
    mt.beneficiarybank,
    mt.cdtaccount,
    mt.currency,
    mt.valuedate,
    to_char(to_number(
        CASE
            WHEN (rtrim((mt.amount)::text) IS NULL) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ''::text) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ','::text) THEN '0,00'::text
            ELSE replace(rtrim((mt.amount)::text), ','::text, '.'::text)
        END, 'FM99999999999999999D99'::text), '9999999999999D99'::text) AS amount,
    eq.queuename,
    eq.payload,
    rm.entity
   FROM ((( SELECT routedmessages.messagetype,
            routedmessages.sender,
            routedmessages.receiver,
            routedmessages.reference,
            routedmessages.correlationid,
            routedmessages.insertdate,
            routedmessages.requestorservice,
            routedmessages.entity
           FROM findata.routedmessages
          WHERE ((routedmessages.currentqueue IS NOT NULL) AND ((routedmessages.messagetype)::text = 'CstmrCdtTrfInitnOthr'::text))) rm
     LEFT JOIN ( SELECT mtcdttrfinitnothrtab.correlationid,
            mtcdttrfinitnothrtab.orderingbank,
            mtcdttrfinitnothrtab.dbtaccount,
            mtcdttrfinitnothrtab.endtoendid,
            mtcdttrfinitnothrtab.cdtcustomername,
            mtcdttrfinitnothrtab.beneficiarybank,
            mtcdttrfinitnothrtab.cdtaccount,
            mtcdttrfinitnothrtab.currency,
            mtcdttrfinitnothrtab.valuedate,
            mtcdttrfinitnothrtab.amount
           FROM findata.mtcdttrfinitnothrtab) mt ON (((rm.correlationid)::text = (mt.correlationid)::text)))
     LEFT JOIN ( SELECT entryqueue.id,
            entryqueue.correlationid,
            entryqueue.queuename,
            entryqueue.payload
           FROM findata.entryqueue) eq ON (((mt.correlationid)::text = (eq.correlationid)::text)));


ALTER TABLE findata.mtcdttrfinitnothrview OWNER TO findata;

--
-- TOC entry 261 (class 1259 OID 63068)
-- Name: mtcdttrfinitnsalatab; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.mtcdttrfinitnsalatab (
    correlationid character varying(30) NOT NULL,
    messagetype character varying(50),
    endtoendid character varying(35),
    dbtcustomername character varying(70),
    dbtaccount character varying(35),
    orderingbank character varying(12),
    amount character varying(50),
    currency character varying(3),
    valuedate character varying(6),
    accountingcode character varying(35),
    locationcode character varying(35),
    budgetcode character varying(35),
    cdtcustomername character varying(70),
    cdtaccount character varying(35),
    beneficiarybank character varying(12),
    remittanceinfo character varying(140)
);


ALTER TABLE findata.mtcdttrfinitnsalatab OWNER TO findata;

--
-- TOC entry 287 (class 1259 OID 173157)
-- Name: mtcdttrfinitnsalaview; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.mtcdttrfinitnsalaview AS
 SELECT eq.id,
    rm.messagetype,
    rm.sender,
    rm.receiver,
    rm.reference,
    rm.requestorservice,
    rm.insertdate,
    mt.orderingbank,
    mt.dbtaccount,
    mt.endtoendid,
    mt.cdtcustomername,
    mt.beneficiarybank,
    mt.cdtaccount,
    mt.currency,
    mt.valuedate,
    to_char(to_number(
        CASE
            WHEN (rtrim((mt.amount)::text) IS NULL) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ''::text) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ','::text) THEN '0,00'::text
            ELSE replace(rtrim((mt.amount)::text), ','::text, '.'::text)
        END, 'FM99999999999999999D99'::text), '9999999999999D99'::text) AS amount,
    eq.queuename,
    eq.payload,
    rm.entity
   FROM ((( SELECT routedmessages.messagetype,
            routedmessages.sender,
            routedmessages.receiver,
            routedmessages.reference,
            routedmessages.correlationid,
            routedmessages.insertdate,
            routedmessages.requestorservice,
            routedmessages.entity
           FROM findata.routedmessages
          WHERE ((routedmessages.currentqueue IS NOT NULL) AND ((routedmessages.messagetype)::text = 'CstmrCdtTrfInitnSala'::text))) rm
     LEFT JOIN ( SELECT mtcdttrfinitnsalatab.correlationid,
            mtcdttrfinitnsalatab.orderingbank,
            mtcdttrfinitnsalatab.dbtaccount,
            mtcdttrfinitnsalatab.endtoendid,
            mtcdttrfinitnsalatab.cdtcustomername,
            mtcdttrfinitnsalatab.beneficiarybank,
            mtcdttrfinitnsalatab.cdtaccount,
            mtcdttrfinitnsalatab.currency,
            mtcdttrfinitnsalatab.valuedate,
            mtcdttrfinitnsalatab.amount
           FROM findata.mtcdttrfinitnsalatab) mt ON (((rm.correlationid)::text = (mt.correlationid)::text)))
     LEFT JOIN ( SELECT entryqueue.id,
            entryqueue.correlationid,
            entryqueue.queuename,
            entryqueue.payload
           FROM findata.entryqueue) eq ON (((mt.correlationid)::text = (eq.correlationid)::text)));


ALTER TABLE findata.mtcdttrfinitnsalaview OWNER TO findata;

--
-- TOC entry 262 (class 1259 OID 63079)
-- Name: mtcdttrfinitnsupptab; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.mtcdttrfinitnsupptab (
    correlationid character varying(30) NOT NULL,
    messagetype character varying(50),
    endtoendid character varying(35),
    dbtcustomername character varying(70),
    dbtaccount character varying(35),
    orderingbank character varying(12),
    amount character varying(50),
    currency character varying(3),
    valuedate character varying(6),
    accountingcode character varying(35),
    locationcode character varying(35),
    budgetcode character varying(35),
    cdtcustomername character varying(70),
    cdtaccount character varying(35),
    beneficiarybank character varying(12),
    remittanceinfo character varying(140)
);


ALTER TABLE findata.mtcdttrfinitnsupptab OWNER TO findata;

--
-- TOC entry 288 (class 1259 OID 173162)
-- Name: mtcdttrfinitnsuppview; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.mtcdttrfinitnsuppview AS
 SELECT eq.id,
    rm.messagetype,
    rm.sender,
    rm.receiver,
    rm.reference,
    rm.requestorservice,
    rm.insertdate,
    mt.orderingbank,
    mt.dbtaccount,
    mt.endtoendid,
    mt.cdtcustomername,
    mt.beneficiarybank,
    mt.cdtaccount,
    mt.currency,
    mt.valuedate,
    to_char(to_number(
        CASE
            WHEN (rtrim((mt.amount)::text) IS NULL) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ''::text) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ','::text) THEN '0,00'::text
            ELSE replace(rtrim((mt.amount)::text), ','::text, '.'::text)
        END, 'FM99999999999999999D99'::text), '9999999999999D99'::text) AS amount,
    eq.queuename,
    eq.payload,
    rm.entity
   FROM ((( SELECT routedmessages.messagetype,
            routedmessages.sender,
            routedmessages.receiver,
            routedmessages.reference,
            routedmessages.correlationid,
            routedmessages.insertdate,
            routedmessages.requestorservice,
            routedmessages.entity
           FROM findata.routedmessages
          WHERE ((routedmessages.currentqueue IS NOT NULL) AND ((routedmessages.messagetype)::text = 'CstmrCdtTrfInitnSupp'::text))) rm
     LEFT JOIN ( SELECT mtcdttrfinitnsupptab.correlationid,
            mtcdttrfinitnsupptab.orderingbank,
            mtcdttrfinitnsupptab.dbtaccount,
            mtcdttrfinitnsupptab.endtoendid,
            mtcdttrfinitnsupptab.cdtcustomername,
            mtcdttrfinitnsupptab.beneficiarybank,
            mtcdttrfinitnsupptab.cdtaccount,
            mtcdttrfinitnsupptab.currency,
            mtcdttrfinitnsupptab.valuedate,
            mtcdttrfinitnsupptab.amount
           FROM findata.mtcdttrfinitnsupptab) mt ON (((rm.correlationid)::text = (mt.correlationid)::text)))
     LEFT JOIN ( SELECT entryqueue.id,
            entryqueue.correlationid,
            entryqueue.queuename,
            entryqueue.payload
           FROM findata.entryqueue) eq ON (((mt.correlationid)::text = (eq.correlationid)::text)));


ALTER TABLE findata.mtcdttrfinitnsuppview OWNER TO findata;

--
-- TOC entry 263 (class 1259 OID 63090)
-- Name: mtcdttrfinitntaxstab; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.mtcdttrfinitntaxstab (
    correlationid character varying(30) NOT NULL,
    messagetype character varying(50),
    endtoendid character varying(35),
    dbtcustomername character varying(70),
    dbtaccount character varying(35),
    orderingbank character varying(12),
    amount character varying(50),
    currency character varying(3),
    valuedate character varying(6),
    accountingcode character varying(35),
    locationcode character varying(35),
    budgetcode character varying(35),
    cdtcustomername character varying(70),
    cdtaccount character varying(35),
    beneficiarybank character varying(12),
    sourcefilename character varying(50),
    remittanceinfo character varying(140)
);


ALTER TABLE findata.mtcdttrfinitntaxstab OWNER TO findata;

--
-- TOC entry 289 (class 1259 OID 173167)
-- Name: mtcdttrfinitntaxsview; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.mtcdttrfinitntaxsview AS
 SELECT eq.id,
    rm.messagetype,
    rm.sender,
    rm.receiver,
    rm.reference,
    rm.requestorservice,
    rm.insertdate,
    mt.orderingbank,
    mt.dbtaccount,
    mt.endtoendid,
    mt.cdtcustomername,
    mt.beneficiarybank,
    mt.cdtaccount,
    mt.currency,
    mt.valuedate,
    to_char(to_number(
        CASE
            WHEN (rtrim((mt.amount)::text) IS NULL) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ''::text) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ','::text) THEN '0,00'::text
            ELSE replace(rtrim((mt.amount)::text), ','::text, '.'::text)
        END, 'FM99999999999999999D99'::text), '9999999999999D99'::text) AS amount,
    eq.queuename,
    eq.payload,
    rm.entity
   FROM ((( SELECT routedmessages.messagetype,
            routedmessages.sender,
            routedmessages.receiver,
            routedmessages.reference,
            routedmessages.correlationid,
            routedmessages.insertdate,
            routedmessages.requestorservice,
            routedmessages.entity
           FROM findata.routedmessages
          WHERE ((routedmessages.currentqueue IS NOT NULL) AND ((routedmessages.messagetype)::text = 'CstmrCdtTrfInitnTaxs'::text))) rm
     LEFT JOIN ( SELECT mtcdttrfinitntaxstab.correlationid,
            mtcdttrfinitntaxstab.orderingbank,
            mtcdttrfinitntaxstab.dbtaccount,
            mtcdttrfinitntaxstab.endtoendid,
            mtcdttrfinitntaxstab.cdtcustomername,
            mtcdttrfinitntaxstab.beneficiarybank,
            mtcdttrfinitntaxstab.cdtaccount,
            mtcdttrfinitntaxstab.currency,
            mtcdttrfinitntaxstab.valuedate,
            mtcdttrfinitntaxstab.amount
           FROM findata.mtcdttrfinitntaxstab) mt ON (((rm.correlationid)::text = (mt.correlationid)::text)))
     LEFT JOIN ( SELECT entryqueue.id,
            entryqueue.correlationid,
            entryqueue.queuename,
            entryqueue.payload
           FROM findata.entryqueue) eq ON (((mt.correlationid)::text = (eq.correlationid)::text)));


ALTER TABLE findata.mtcdttrfinitntaxsview OWNER TO findata;

--
-- TOC entry 264 (class 1259 OID 63101)
-- Name: mtcdttrfinitnvatxtab; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.mtcdttrfinitnvatxtab (
    correlationid character varying(30) NOT NULL,
    messagetype character varying(50),
    endtoendid character varying(35),
    dbtcustomername character varying(70),
    dbtaccount character varying(35),
    orderingbank character varying(12),
    amount character varying(50),
    currency character varying(3),
    valuedate character varying(6),
    accountingcode character varying(35),
    locationcode character varying(35),
    budgetcode character varying(35),
    cdtcustomername character varying(70),
    cdtaccount character varying(35),
    beneficiarybank character varying(12),
    remittanceinfo character varying(140)
);


ALTER TABLE findata.mtcdttrfinitnvatxtab OWNER TO findata;

--
-- TOC entry 286 (class 1259 OID 173152)
-- Name: mtcdttrfinitnvatxview; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.mtcdttrfinitnvatxview AS
 SELECT eq.id,
    rm.messagetype,
    rm.sender,
    rm.receiver,
    rm.reference,
    rm.requestorservice,
    rm.insertdate,
    mt.orderingbank,
    mt.dbtaccount,
    mt.endtoendid,
    mt.cdtcustomername,
    mt.beneficiarybank,
    mt.cdtaccount,
    mt.currency,
    mt.valuedate,
    to_char(to_number(
        CASE
            WHEN (rtrim((mt.amount)::text) IS NULL) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ''::text) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ','::text) THEN '0,00'::text
            ELSE replace(rtrim((mt.amount)::text), ','::text, '.'::text)
        END, 'FM99999999999999999D99'::text), '9999999999999D99'::text) AS amount,
    eq.queuename,
    eq.payload,
    rm.entity
   FROM ((( SELECT routedmessages.messagetype,
            routedmessages.sender,
            routedmessages.receiver,
            routedmessages.reference,
            routedmessages.correlationid,
            routedmessages.insertdate,
            routedmessages.requestorservice,
            routedmessages.entity
           FROM findata.routedmessages
          WHERE ((routedmessages.currentqueue IS NOT NULL) AND ((routedmessages.messagetype)::text = 'CstmrCdtTrfInitnVatx'::text))) rm
     LEFT JOIN ( SELECT mtcdttrfinitnvatxtab.correlationid,
            mtcdttrfinitnvatxtab.orderingbank,
            mtcdttrfinitnvatxtab.dbtaccount,
            mtcdttrfinitnvatxtab.endtoendid,
            mtcdttrfinitnvatxtab.cdtcustomername,
            mtcdttrfinitnvatxtab.beneficiarybank,
            mtcdttrfinitnvatxtab.cdtaccount,
            mtcdttrfinitnvatxtab.currency,
            mtcdttrfinitnvatxtab.valuedate,
            mtcdttrfinitnvatxtab.amount
           FROM findata.mtcdttrfinitnvatxtab) mt ON (((rm.correlationid)::text = (mt.correlationid)::text)))
     LEFT JOIN ( SELECT entryqueue.id,
            entryqueue.correlationid,
            entryqueue.queuename,
            entryqueue.payload
           FROM findata.entryqueue) eq ON (((mt.correlationid)::text = (eq.correlationid)::text)));


ALTER TABLE findata.mtcdttrfinitnvatxview OWNER TO findata;

--
-- TOC entry 282 (class 1259 OID 135533)
-- Name: mtfininvctab; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.mtfininvctab (
    correlationid character varying(30) NOT NULL,
    messagetype character varying(50),
    dbtcustomername character varying(35),
    cdtcustomername character varying(35),
    invoiceno character varying(35),
    invoiceserial character varying(4),
    amount character varying(18),
    currency character varying(3),
    originalreference character varying(35),
    cdtaccount character varying(35),
    maturitydate character varying(6),
    issuancedate character varying(6),
    invoicetype character varying(35)
);


ALTER TABLE findata.mtfininvctab OWNER TO findata;

--
-- TOC entry 284 (class 1259 OID 147269)
-- Name: mtfininvcview; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.mtfininvcview AS
 SELECT eq.id,
    rm.messagetype,
    rm.sender,
    rm.receiver,
    rm.reference,
    rm.requestorservice,
    rm.insertdate,
    eq.queuename,
    eq.payload,
    rm.entity,
    mt.dbtcustomername,
    mt.cdtcustomername,
    mt.invoiceno,
    mt.invoiceserial,
    mt.issuancedate,
    mt.originalreference,
    to_char(to_number(
        CASE
            WHEN (rtrim((mt.amount)::text) IS NULL) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ''::text) THEN '0,00'::text
            WHEN (rtrim((mt.amount)::text) = ','::text) THEN '0,00'::text
            ELSE replace(rtrim((mt.amount)::text), ','::text, '.'::text)
        END, 'FM99999999999999999D99'::text), '9,999,999,999,999D99'::text) AS amount
   FROM ((( SELECT routedmessages.messagetype,
            routedmessages.sender,
            routedmessages.receiver,
            routedmessages.reference,
            routedmessages.requestorservice,
            routedmessages.insertdate,
            routedmessages.correlationid,
            routedmessages.entity
           FROM findata.routedmessages
          WHERE ((routedmessages.currentqueue IS NOT NULL) AND ((routedmessages.messagetype)::text = 'FinInvc'::text))) rm
     LEFT JOIN ( SELECT mtfininvctab.dbtcustomername,
            mtfininvctab.cdtcustomername,
            mtfininvctab.invoiceno,
            mtfininvctab.invoiceserial,
            mtfininvctab.issuancedate,
            mtfininvctab.originalreference,
            mtfininvctab.correlationid,
            mtfininvctab.amount
           FROM findata.mtfininvctab) mt ON (((rm.correlationid)::text = (mt.correlationid)::text)))
     LEFT JOIN ( SELECT entryqueue.id,
            entryqueue.correlationid,
            entryqueue.queuename,
            entryqueue.payload
           FROM findata.entryqueue) eq ON (((mt.correlationid)::text = (eq.correlationid)::text)));


ALTER TABLE findata.mtfininvcview OWNER TO findata;

--
-- TOC entry 265 (class 1259 OID 63184)
-- Name: mtundefinedview; Type: VIEW; Schema: findata; Owner: postgres
--

CREATE VIEW findata.mtundefinedview AS
 SELECT entryqueue.id,
    entryqueue.batchid,
    entryqueue.requestorservice,
    entryqueue.correlationid,
    entryqueue.queuename,
    entryqueue.payload
   FROM findata.entryqueue
  WHERE (NOT ((entryqueue.correlationid)::text IN ( SELECT routedmessages.correlationid
           FROM findata.routedmessages)));


ALTER TABLE findata.mtundefinedview OWNER TO postgres;

--
-- TOC entry 335 (class 1259 OID 2022586)
-- Name: repbalancesheet; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.repbalancesheet (
    entity character varying(20) NOT NULL,
    year integer NOT NULL,
    omfp1 numeric(17,2) NOT NULL,
    omfp2 numeric(17,2) NOT NULL,
    omfp3 numeric(17,2) NOT NULL,
    omfp5 numeric(17,2) NOT NULL,
    omfp8 numeric(17,2) NOT NULL,
    omfp9 numeric(17,2) NOT NULL,
    omfp10 numeric(17,2) NOT NULL,
    omfp11 numeric(17,2) NOT NULL,
    omfp12 numeric(17,2) NOT NULL,
    omfp31 numeric(17,2) NOT NULL,
    omfp39 numeric(17,2) NOT NULL,
    omfp45 numeric(17,2),
    omfp46 numeric(17,2),
    omfp47 numeric(17,2) NOT NULL,
    omfp43 numeric(17,2),
    omfp44 numeric(17,2),
    omfp48 numeric(17,2) NOT NULL,
    omfp18 numeric(17,2) NOT NULL,
    omfp19 numeric(17,2) NOT NULL,
    omfp20 numeric(17,2) NOT NULL,
    omfp15 numeric(17,2) NOT NULL,
    totalact numeric(17,2) NOT NULL,
    totalactimob numeric(17,2) NOT NULL,
    totalcapstr numeric(17,2) NOT NULL,
    totalpas numeric(17,2) NOT NULL,
    id integer NOT NULL,
    CONSTRAINT ck_only_onec5 CHECK ((((omfp45 IS NULL) OR (omfp46 IS NULL)) AND (NOT ((omfp45 IS NULL) AND (omfp46 IS NULL))))),
    CONSTRAINT ck_only_onec6 CHECK ((((omfp43 IS NULL) OR (omfp44 IS NULL)) AND (NOT ((omfp43 IS NULL) AND (omfp44 IS NULL)))))
);


ALTER TABLE findata.repbalancesheet OWNER TO findata;

--
-- TOC entry 268 (class 1259 OID 63227)
-- Name: status; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.status (
    guid character varying(30) NOT NULL,
    service integer NOT NULL,
    correlationid character varying(30) NOT NULL,
    type character varying(20) NOT NULL,
    machine character varying(50) NOT NULL,
    eventdate timestamp without time zone NOT NULL,
    insertdate timestamp without time zone NOT NULL,
    message character varying(256) NOT NULL,
    class character varying(100),
    innerexception character varying(4000),
    additionalinfo text,
    sessionid character varying(30),
    userid integer
);


ALTER TABLE findata.status OWNER TO findata;

--
-- TOC entry 340 (class 1259 OID 2023571)
-- Name: repevents; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.repevents AS
 SELECT status.eventdate,
    status.type,
        CASE
            WHEN ((status.userid IS NULL) OR (status.userid = 0)) THEN 'n/a'::character varying
            ELSE fincfg.getusername(status.userid)
        END AS username,
        CASE
            WHEN (status.service = '-1'::integer) THEN 'User'::character varying
            ELSE fincfg.getservicename(status.service)
        END AS service,
        CASE
            WHEN ((status.class)::text = ANY (ARRAY[('Config.Manage'::character varying)::text, ('Transaction.Operate'::character varying)::text, ('Transaction.Fetch'::character varying)::text, ('Transaction.Publish'::character varying)::text, ('Transaction.Route'::character varying)::text, ('BalanceSheet.Manage'::character varying)::text])) THEN 'business'::text
            WHEN ((status.class)::text = 'User.Manage'::text) THEN 'security'::text
            WHEN (((status.class)::text = 'Application.Config'::text) OR ((status.class)::text = 'no class'::text)) THEN 'application'::text
            ELSE 'unknown'::text
        END AS actiontype,
    status.class,
    status.message,
    status.machine,
    status.guid,
    status.correlationid,
    status.additionalinfo,
    status.innerexception
   FROM findata.status;


ALTER TABLE findata.repevents OWNER TO findata;

--
-- TOC entry 336 (class 1259 OID 2022593)
-- Name: repprofitandloss; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.repprofitandloss (
    entity character varying(20) NOT NULL,
    year integer NOT NULL,
    omfp3 numeric(17,2) NOT NULL,
    omfp2 numeric(17,2) NOT NULL,
    omfp1 numeric(17,2) NOT NULL,
    omfp8 numeric(17,2) NOT NULL,
    omfp11 numeric(17,2) NOT NULL,
    omfp12 numeric(17,2) NOT NULL,
    omfp15 numeric(17,2) NOT NULL,
    omfp16 numeric(17,2) NOT NULL,
    omfp17 numeric(17,2) NOT NULL,
    omfp18 numeric(17,2) NOT NULL,
    omfp19 numeric(17,2) NOT NULL,
    omfp21 numeric(17,2) NOT NULL,
    omfp24 numeric(17,2) NOT NULL,
    omfp30 numeric(17,2) NOT NULL,
    omfp40 numeric(17,2) NOT NULL,
    omfp41 numeric(17,2),
    omfp42 numeric(17,2),
    omfp45 numeric(17,2) NOT NULL,
    omfp48 numeric(17,2) NOT NULL,
    omfp50 numeric(17,2) NOT NULL,
    omfp54 numeric(17,2) NOT NULL,
    omfp56 numeric(17,2) NOT NULL,
    omfp57 numeric(17,2) NOT NULL,
    omfp58 numeric(17,2),
    omfp59 numeric(17,2),
    omfp60 numeric(17,2) NOT NULL,
    omfp61 numeric(17,2) NOT NULL,
    omfp62 numeric(17,2),
    omfp63 numeric(17,2),
    omfp64 numeric(17,2) NOT NULL,
    omfp67 numeric(17,2),
    omfp68 numeric(17,2),
    id integer NOT NULL,
    CONSTRAINT ck_only_onec1 CHECK ((((omfp41 IS NULL) OR (omfp42 IS NULL)) AND (NOT ((omfp41 IS NULL) AND (omfp42 IS NULL))))),
    CONSTRAINT ck_only_onec2 CHECK ((((omfp58 IS NULL) OR (omfp59 IS NULL)) AND (NOT ((omfp58 IS NULL) AND (omfp59 IS NULL))))),
    CONSTRAINT ck_only_onec3 CHECK ((((omfp62 IS NULL) OR (omfp63 IS NULL)) AND (NOT ((omfp62 IS NULL) AND (omfp63 IS NULL))))),
    CONSTRAINT ck_only_onec4 CHECK ((((omfp67 IS NULL) OR (omfp68 IS NULL)) AND (NOT ((omfp67 IS NULL) AND (omfp68 IS NULL)))))
);


ALTER TABLE findata.repprofitandloss OWNER TO findata;

--
-- TOC entry 337 (class 1259 OID 2023193)
-- Name: repstatinvc; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.repstatinvc AS
 SELECT ba.id,
    fb.correlationid,
    ba.insertdate,
    ba.invoicetype,
    ba.reference,
    ba.cdtcustomername,
    ba.dbtcustomername,
    ba.invoiceno,
    ba.invoiceserial,
    ba.amount,
    ba.currency,
    ba.originalreference,
    ba.cdtaccount,
    ba.maturitydate,
    ba.entity,
        CASE
            WHEN (ba.currentqueue IS NOT NULL) THEN "substring"((ba.status)::text, ("position"((ba.status)::text, '~~'::text) + 2))
            ELSE ''::text
        END AS queuename,
        CASE
            WHEN ((ba.status)::text ~~ '%~~%'::text) THEN ("substring"((ba.status)::text, 1, ("position"((ba.status)::text, '~~'::text) - 1)))::character varying
            ELSE ba.status
        END AS status,
    fb.sourcefilename,
    fb.destinationfilename,
    fb.operationdetails,
    ba.requestorservice,
    ba.messagetype
   FROM (( SELECT rm.correlationid,
            rm.insertdate,
            mt.invoicetype,
            rm.reference,
            rm.id,
            rm.requestorservice,
            mt.cdtcustomername,
            mt.dbtcustomername,
            mt.invoiceno,
            mt.invoiceserial,
            to_number(
                CASE
                    WHEN (rtrim((mt.amount)::text) IS NULL) THEN '0,00'::text
                    WHEN (rtrim((mt.amount)::text) = ''::text) THEN '0,00'::text
                    WHEN (rtrim((mt.amount)::text) = ','::text) THEN '0,00'::text
                    ELSE replace(rtrim((mt.amount)::text), ','::text, '.'::text)
                END, 'FM99999999999999999D99'::text) AS amount,
            mt.currency,
            mt.originalreference,
            mt.cdtaccount,
            mt.maturitydate,
            findata.getstatus(rm.correlationid) AS status,
            rm.currentqueue,
            rm.entity,
            fincfg.getmsgtypebusinessname(rm.messagetype) AS messagetype
           FROM (( SELECT routedmessages.reference,
                    routedmessages.currentqueue,
                    routedmessages.requestorservice,
                    routedmessages.insertdate,
                    routedmessages.correlationid,
                    routedmessages.entity,
                    routedmessages.id,
                    routedmessages.messagetype
                   FROM findata.routedmessages) rm
             JOIN ( SELECT mtfininvctab.invoicetype,
                    mtfininvctab.cdtcustomername,
                    mtfininvctab.dbtcustomername,
                    mtfininvctab.invoiceno,
                    mtfininvctab.invoiceserial,
                    mtfininvctab.originalreference,
                    mtfininvctab.correlationid,
                    mtfininvctab.currency,
                    mtfininvctab.cdtaccount,
                    mtfininvctab.maturitydate,
                    mtfininvctab.amount
                   FROM findata.mtfininvctab) mt ON (((rm.correlationid)::text = (mt.correlationid)::text)))) ba
     LEFT JOIN ( SELECT feedbackagg.correlationid,
            feedbackagg.sourcefilename,
            feedbackagg.destinationfilename,
            feedbackagg.operationdetails
           FROM findata.feedbackagg) fb ON (((ba.correlationid)::text = (fb.correlationid)::text)));


ALTER TABLE findata.repstatinvc OWNER TO findata;

--
-- TOC entry 315 (class 1259 OID 193623)
-- Name: repstatstmt; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.repstatstmt AS
 SELECT ba.id,
    fb.correlationid,
    ba.messagetype,
    ba.reference,
    ba.amount,
    ba.currency,
    to_char((to_date((ba.valuedate)::text, 'YYMMDD'::text))::timestamp with time zone, 'yyyy-mm-dd'::text) AS valuedate,
        CASE
            WHEN ((ba.status)::text ~~ '%~~%'::text) THEN ("substring"((ba.status)::text, 1, ("position"((ba.status)::text, '~~'::text) - 1)))::character varying
            ELSE ba.status
        END AS status,
    fb.sourcefilename,
    ba.remittanceinfo,
    ((ba.openbalancedate1 || ' - '::text) || ba.closebalancedate1) AS statementdate,
    ba.statementnumber,
    ba.statementreference,
    ba.name,
    ba.accountnumber,
    ba.trxmark,
    ba.insertdate,
    to_char(ba.insertdate, 'yyyy-mm-dd hh24:mi:ss'::text) AS insertdatech,
    fb.operationdetails,
    ba.requestorservice,
        CASE
            WHEN (ba.currentqueue IS NOT NULL) THEN "substring"((ba.status)::text, ("position"((ba.status)::text, '~~'::text) + 2))
            ELSE ''::text
        END AS queuename,
    fb.destinationfilename,
    ba.openbalancedate1 AS openbalancedate,
    ba.closebalancedate1 AS closebalancedate,
    to_char(ba.amount, '9,999,999,999,999D99'::text) AS amountchar,
    ba.entity
   FROM (( SELECT fincfg.getmsgtypebusinessname(rm.messagetype) AS messagetype,
            rm.reference,
            rm.id,
            to_number(
                CASE
                    WHEN (rtrim((mt.amount)::text) IS NULL) THEN '0,00'::text
                    WHEN (rtrim((mt.amount)::text) = ''::text) THEN '0,00'::text
                    WHEN (rtrim((mt.amount)::text) = ','::text) THEN '0,00'::text
                    ELSE replace(rtrim((mt.amount)::text), ','::text, '.'::text)
                END, 'FM99999999999999999D99'::text) AS amount,
            mt.currency,
            mt.valuedate,
            mt.correlationid,
            findata.getstatus(rm.correlationid) AS status,
            mt.remittanceinfo,
            to_char((to_date((mt.openbalancedate)::text, 'YYMMDD'::text))::timestamp with time zone, 'yyyy-mm-dd'::text) AS openbalancedate1,
            to_char((to_date((mt.closebalancedate)::text, 'YYMMDD'::text))::timestamp with time zone, 'yyyy-mm-dd'::text) AS closebalancedate1,
            mt.statementnumber,
            mt.statementreference,
            mt.name,
            mt.accountnumber,
            mt.trxmark,
            rm.insertdate,
            rm.requestorservice,
            rm.currentqueue,
            rm.entity
           FROM (( SELECT routedmessages.messagetype,
                    routedmessages.reference,
                    routedmessages.correlationid,
                    routedmessages.currentqueue,
                    routedmessages.insertdate,
                    routedmessages.requestorservice,
                    routedmessages.entity,
                    routedmessages.id
                   FROM findata.routedmessages) rm
             JOIN ( SELECT mtbktocstmrdbtcdttab.correlationid,
                    mtbktocstmrdbtcdttab.amount,
                    mtbktocstmrdbtcdttab.currency,
                    mtbktocstmrdbtcdttab.valuedate,
                    mtbktocstmrdbtcdttab.remittanceinfo,
                    mtbktocstmrdbtcdttab.openbalancedate,
                    mtbktocstmrdbtcdttab.closebalancedate,
                    mtbktocstmrdbtcdttab.statementnumber,
                    mtbktocstmrdbtcdttab.statementreference,
                    mtbktocstmrdbtcdttab.name,
                    mtbktocstmrdbtcdttab.accountnumber,
                    mtbktocstmrdbtcdttab.trxmark
                   FROM findata.mtbktocstmrdbtcdttab) mt ON (((rm.correlationid)::text = (mt.correlationid)::text)))) ba
     LEFT JOIN ( SELECT feedbackagg.correlationid,
            feedbackagg.sourcefilename,
            feedbackagg.operationdetails,
            feedbackagg.destinationfilename
           FROM findata.feedbackagg) fb ON (((ba.correlationid)::text = (fb.correlationid)::text)));


ALTER TABLE findata.repstatstmt OWNER TO findata;

--
-- TOC entry 338 (class 1259 OID 2023287)
-- Name: repreconinvissvsstatement; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.repreconinvissvsstatement AS
 SELECT row_number() OVER () AS id,
    st.reference AS stmtreference,
    st.name AS stmtname,
    st.amount AS stmtamount,
    st.currency AS stmtcurrency,
    st.accountnumber AS stmtaccountnumber,
    st.remittanceinfo AS stmtremittanceinfo,
    st.valuedate AS stmtvaluedate,
    st.correlationid AS stmtcorrelationid,
    st.statementnumber AS stmtstatementnumber,
    inv.reference AS invreference,
    inv.amount AS invamount,
    inv.currency AS invcurrency,
    inv.dbtcustomername AS invdbtcustomername,
    to_char((to_date((inv.maturitydate)::text, 'YYMMDD'::text))::timestamp with time zone, 'yyyy-mm-dd'::text) AS invmaturitydate,
    inv.cdtaccount AS invcdtaccount,
    inv.cdtcustomername AS invcdtcustomername,
    inv.invoiceno AS invinvoiceno,
    inv.invoiceserial AS invinvoiceserial,
    inv.correlationid AS invcorrelationid,
        CASE
            WHEN ((st.correlationid IS NOT NULL) AND (inv.correlationid IS NOT NULL)) THEN 'Match'::text
            ELSE 'Unmatch'::text
        END AS matchtype
   FROM (( SELECT repstatstmt.correlationid,
            repstatstmt.messagetype,
            repstatstmt.reference,
            repstatstmt.amount,
            repstatstmt.currency,
            repstatstmt.valuedate,
            repstatstmt.status,
            repstatstmt.sourcefilename,
            repstatstmt.remittanceinfo,
            repstatstmt.statementdate,
            repstatstmt.statementnumber,
            repstatstmt.statementreference,
            repstatstmt.name,
            repstatstmt.accountnumber,
            repstatstmt.trxmark,
            repstatstmt.insertdate,
            repstatstmt.operationdetails,
            repstatstmt.requestorservice,
            repstatstmt.queuename,
            repstatstmt.destinationfilename
           FROM findata.repstatstmt
          WHERE ((repstatstmt.trxmark)::text = 'CRDT'::text)) st
     FULL JOIN ( SELECT repstatinvc.correlationid,
            repstatinvc.insertdate,
            repstatinvc.invoicetype,
            repstatinvc.reference,
            repstatinvc.cdtcustomername,
            repstatinvc.dbtcustomername,
            repstatinvc.invoiceno,
            repstatinvc.invoiceserial,
            repstatinvc.amount,
            repstatinvc.currency,
            repstatinvc.originalreference,
            repstatinvc.cdtaccount,
            repstatinvc.maturitydate,
            repstatinvc.entity
           FROM findata.repstatinvc
          WHERE ((repstatinvc.invoicetype)::text = 'Issued'::text)) inv ON ((((st.name)::text = (inv.cdtcustomername)::text) AND ((st.amount)::text = (inv.amount)::text) AND ((st.currency)::text = (inv.currency)::text))));


ALTER TABLE findata.repreconinvissvsstatement OWNER TO findata;

--
-- TOC entry 339 (class 1259 OID 2023292)
-- Name: repreconinvsuppvsstatement; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.repreconinvsuppvsstatement AS
 SELECT row_number() OVER () AS id,
    st.reference AS stmtreference,
    st.name AS stmtname,
    st.amount AS stmtamount,
    st.currency AS stmtcurrency,
    st.accountnumber AS stmtaccountnumber,
    st.remittanceinfo AS stmtremittanceinfo,
    st.valuedate AS stmtvaluedate,
    st.correlationid AS stmtcorrelationid,
    st.statementnumber AS stmtstatementnumber,
    inv.reference AS invreference,
    inv.amount AS invamount,
    inv.currency AS invcurrency,
    inv.dbtcustomername AS invdbtcustomername,
    to_char((to_date((inv.maturitydate)::text, 'YYMMDD'::text))::timestamp with time zone, 'yyyy-mm-dd'::text) AS invmaturitydate,
    inv.cdtaccount AS invcdtaccount,
    inv.cdtcustomername AS invcdtcustomername,
    inv.invoiceno AS invinvoiceno,
    inv.invoiceserial AS invinvoiceserial,
    inv.correlationid AS invcorrelationid,
        CASE
            WHEN ((st.correlationid IS NOT NULL) AND (inv.correlationid IS NOT NULL)) THEN 'Match'::text
            ELSE 'Unmatch'::text
        END AS matchtype
   FROM (( SELECT repstatstmt.correlationid,
            repstatstmt.messagetype,
            repstatstmt.reference,
            repstatstmt.amount,
            repstatstmt.currency,
            repstatstmt.valuedate,
            repstatstmt.status,
            repstatstmt.sourcefilename,
            repstatstmt.remittanceinfo,
            repstatstmt.statementdate,
            repstatstmt.statementnumber,
            repstatstmt.statementreference,
            repstatstmt.name,
            repstatstmt.accountnumber,
            repstatstmt.trxmark,
            repstatstmt.insertdate,
            repstatstmt.operationdetails,
            repstatstmt.requestorservice,
            repstatstmt.queuename,
            repstatstmt.destinationfilename
           FROM findata.repstatstmt
          WHERE ((repstatstmt.trxmark)::text = 'DBIT'::text)) st
     FULL JOIN ( SELECT repstatinvc.correlationid,
            repstatinvc.insertdate,
            repstatinvc.invoicetype,
            repstatinvc.reference,
            repstatinvc.cdtcustomername,
            repstatinvc.dbtcustomername,
            repstatinvc.invoiceno,
            repstatinvc.invoiceserial,
            repstatinvc.amount,
            repstatinvc.currency,
            repstatinvc.originalreference,
            repstatinvc.cdtaccount,
            repstatinvc.maturitydate,
            repstatinvc.entity
           FROM findata.repstatinvc
          WHERE ((repstatinvc.invoicetype)::text = 'Received'::text)) inv ON ((((st.reference)::text = (inv.reference)::text) AND ((st.name)::text = (inv.dbtcustomername)::text) AND ((st.amount)::text = (inv.amount)::text) AND ((st.currency)::text = (inv.currency)::text))));


ALTER TABLE findata.repreconinvsuppvsstatement OWNER TO findata;

--
-- TOC entry 314 (class 1259 OID 193618)
-- Name: repstatpymt; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.repstatpymt AS
 SELECT ba.id,
    fb.correlationid,
    ba.messagetype,
    ba.endtoendid,
    ba.reference,
    ba.dbtcustomername,
    ba.dbtaccount,
    ba.orderingbank,
    ba.amount,
    ba.currency,
    to_char((to_date((ba.valuedate)::text, 'YYMMDD'::text))::timestamp with time zone, 'yyyy-mm-dd'::text) AS valuedate,
    ba.accountingcode,
    ba.locationcode,
    ba.budgetcode,
        CASE
            WHEN (ba.currentqueue IS NOT NULL) THEN "substring"((ba.status)::text, ("position"((ba.status)::text, '~~'::text) + 2))
            ELSE ''::text
        END AS queuename,
        CASE
            WHEN ((ba.status)::text ~~ '%~~%'::text) THEN ("substring"((ba.status)::text, 1, ("position"((ba.status)::text, '~~'::text) - 1)))::character varying
            ELSE ba.status
        END AS status,
    ba.cdtcustomername,
    ba.cdtaccount,
    ba.beneficiarybank,
    fb.sourcefilename,
    fb.destinationfilename,
    ba.remittanceinfo,
    ba.insertdate,
    fb.operationdetails,
    ba.requestorservice,
    ba.paymentid,
    ba.entity
   FROM (( SELECT fincfg.getmsgtypebusinessname(rm.messagetype) AS messagetype,
            mt.endtoendid,
            rm.reference,
            rm.id,
            mt.dbtcustomername,
            mt.dbtaccount,
            mt.orderingbank,
            to_number(
                CASE
                    WHEN (rtrim((mt.amount)::text) IS NULL) THEN '0,00'::text
                    WHEN (rtrim((mt.amount)::text) = ''::text) THEN '0,00'::text
                    WHEN (rtrim((mt.amount)::text) = ','::text) THEN '0,00'::text
                    ELSE replace(rtrim((mt.amount)::text), ','::text, '.'::text)
                END, 'FM99999999999999999D99'::text) AS amount,
            mt.currency,
            mt.valuedate,
            mt.accountingcode,
            mt.locationcode,
            mt.budgetcode,
            mt.correlationid,
            findata.getstatus(rm.correlationid) AS status,
            rm.currentqueue,
            mt.cdtcustomername,
            mt.cdtaccount,
            mt.beneficiarybank,
            mt.remittanceinfo,
            rm.insertdate,
            rm.requestorservice,
            rm.paymentid,
            rm.entity
           FROM (( SELECT routedmessages.messagetype,
                    routedmessages.reference,
                    routedmessages.correlationid,
                    routedmessages.currentqueue,
                    routedmessages.insertdate,
                    routedmessages.requestorservice,
                    routedmessages.paymentid,
                    routedmessages.id,
                    routedmessages.entity
                   FROM findata.routedmessages) rm
             JOIN ( SELECT mtcdttrfinitnothrtab.correlationid,
                    mtcdttrfinitnothrtab.endtoendid,
                    mtcdttrfinitnothrtab.dbtcustomername,
                    mtcdttrfinitnothrtab.dbtaccount,
                    mtcdttrfinitnothrtab.orderingbank,
                    mtcdttrfinitnothrtab.amount,
                    mtcdttrfinitnothrtab.currency,
                    mtcdttrfinitnothrtab.valuedate,
                    mtcdttrfinitnothrtab.accountingcode,
                    mtcdttrfinitnothrtab.locationcode,
                    mtcdttrfinitnothrtab.budgetcode,
                    mtcdttrfinitnothrtab.cdtcustomername,
                    mtcdttrfinitnothrtab.cdtaccount,
                    mtcdttrfinitnothrtab.beneficiarybank,
                    mtcdttrfinitnothrtab.remittanceinfo
                   FROM findata.mtcdttrfinitnothrtab
                UNION ALL
                 SELECT mtcdttrfinitnsupptab.correlationid,
                    mtcdttrfinitnsupptab.endtoendid,
                    mtcdttrfinitnsupptab.dbtcustomername,
                    mtcdttrfinitnsupptab.dbtaccount,
                    mtcdttrfinitnsupptab.orderingbank,
                    mtcdttrfinitnsupptab.amount,
                    mtcdttrfinitnsupptab.currency,
                    mtcdttrfinitnsupptab.valuedate,
                    mtcdttrfinitnsupptab.accountingcode,
                    mtcdttrfinitnsupptab.locationcode,
                    mtcdttrfinitnsupptab.budgetcode,
                    mtcdttrfinitnsupptab.cdtcustomername,
                    mtcdttrfinitnsupptab.cdtaccount,
                    mtcdttrfinitnsupptab.beneficiarybank,
                    mtcdttrfinitnsupptab.remittanceinfo
                   FROM findata.mtcdttrfinitnsupptab
                UNION ALL
                 SELECT mtcdttrfinitnsalatab.correlationid,
                    mtcdttrfinitnsalatab.endtoendid,
                    mtcdttrfinitnsalatab.dbtcustomername,
                    mtcdttrfinitnsalatab.dbtaccount,
                    mtcdttrfinitnsalatab.orderingbank,
                    mtcdttrfinitnsalatab.amount,
                    mtcdttrfinitnsalatab.currency,
                    mtcdttrfinitnsalatab.valuedate,
                    mtcdttrfinitnsalatab.accountingcode,
                    mtcdttrfinitnsalatab.locationcode,
                    mtcdttrfinitnsalatab.budgetcode,
                    mtcdttrfinitnsalatab.cdtcustomername,
                    mtcdttrfinitnsalatab.cdtaccount,
                    mtcdttrfinitnsalatab.beneficiarybank,
                    mtcdttrfinitnsalatab.remittanceinfo
                   FROM findata.mtcdttrfinitnsalatab
                UNION ALL
                 SELECT mtcdttrfinitntaxstab.correlationid,
                    mtcdttrfinitntaxstab.endtoendid,
                    mtcdttrfinitntaxstab.dbtcustomername,
                    mtcdttrfinitntaxstab.dbtaccount,
                    mtcdttrfinitntaxstab.orderingbank,
                    mtcdttrfinitntaxstab.amount,
                    mtcdttrfinitntaxstab.currency,
                    mtcdttrfinitntaxstab.valuedate,
                    mtcdttrfinitntaxstab.accountingcode,
                    mtcdttrfinitntaxstab.locationcode,
                    mtcdttrfinitntaxstab.budgetcode,
                    mtcdttrfinitntaxstab.cdtcustomername,
                    mtcdttrfinitntaxstab.cdtaccount,
                    mtcdttrfinitntaxstab.beneficiarybank,
                    mtcdttrfinitntaxstab.remittanceinfo
                   FROM findata.mtcdttrfinitntaxstab
                UNION ALL
                 SELECT mtcdttrfinitnvatxtab.correlationid,
                    mtcdttrfinitnvatxtab.endtoendid,
                    mtcdttrfinitnvatxtab.dbtcustomername,
                    mtcdttrfinitnvatxtab.dbtaccount,
                    mtcdttrfinitnvatxtab.orderingbank,
                    mtcdttrfinitnvatxtab.amount,
                    mtcdttrfinitnvatxtab.currency,
                    mtcdttrfinitnvatxtab.valuedate,
                    mtcdttrfinitnvatxtab.accountingcode,
                    mtcdttrfinitnvatxtab.locationcode,
                    mtcdttrfinitnvatxtab.budgetcode,
                    mtcdttrfinitnvatxtab.cdtcustomername,
                    mtcdttrfinitnvatxtab.cdtaccount,
                    mtcdttrfinitnvatxtab.beneficiarybank,
                    mtcdttrfinitnvatxtab.remittanceinfo
                   FROM findata.mtcdttrfinitnvatxtab) mt ON (((rm.correlationid)::text = (mt.correlationid)::text)))) ba
     LEFT JOIN ( SELECT feedbackagg.correlationid,
            feedbackagg.sourcefilename,
            feedbackagg.destinationfilename,
            feedbackagg.operationdetails
           FROM findata.feedbackagg) fb ON (((ba.correlationid)::text = (fb.correlationid)::text)));


ALTER TABLE findata.repstatpymt OWNER TO findata;

--
-- TOC entry 328 (class 1259 OID 2012884)
-- Name: repreconpaymentvsstatement; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.repreconpaymentvsstatement AS
 SELECT row_number() OVER () AS id,
    st.reference AS stmtreference,
    st.name AS stmtname,
    st.amount AS stmtamount,
    st.currency AS stmtcurrency,
    st.accountnumber AS stmtaccountnumber,
    st.remittanceinfo AS stmtremittanceinfo,
    st.valuedate AS stmtvaluedate,
    st.correlationid AS stmtcorrelationid,
    st.statementnumber AS stmtstatementnumber,
    py.messagetype AS pymtmessagetype,
    py.endtoendid AS pymtendtoendid,
    py.dbtcustomername AS pymtdbtcustomername,
    py.amount AS pymtamount,
    py.currency AS pymtcurrency,
    py.dbtaccount AS pymtdbtaccount,
    py.remittanceinfo AS pymtremittanceinfo,
    py.valuedate AS pymtvaluedate,
    py.cdtcustomername AS pymtcdtcustomername,
    py.cdtaccount AS pymtcdtaccount,
    py.correlationid AS pymtcorrelationid,
        CASE
            WHEN ((st.correlationid IS NOT NULL) AND (py.correlationid IS NOT NULL)) THEN 'Match'::text
            ELSE 'Unmatch'::text
        END AS matchtype
   FROM (( SELECT repstatstmt.correlationid,
            repstatstmt.messagetype,
            repstatstmt.reference,
            repstatstmt.amount,
            repstatstmt.currency,
            repstatstmt.valuedate,
            repstatstmt.status,
            repstatstmt.sourcefilename,
            repstatstmt.remittanceinfo,
            repstatstmt.statementdate,
            repstatstmt.statementnumber,
            repstatstmt.statementreference,
            repstatstmt.name,
            repstatstmt.accountnumber,
            repstatstmt.trxmark,
            repstatstmt.insertdate,
            repstatstmt.operationdetails,
            repstatstmt.requestorservice,
            repstatstmt.queuename,
            repstatstmt.destinationfilename
           FROM findata.repstatstmt
          WHERE ((repstatstmt.trxmark)::text = 'DBIT'::text)) st
     FULL JOIN findata.repstatpymt py ON ((((st.reference)::text = (py.endtoendid)::text) AND ((st.name)::text = (py.dbtcustomername)::text) AND ((st.accountnumber)::text = (py.dbtaccount)::text) AND ((st.amount)::text = (py.amount)::text) AND ((st.currency)::text = (py.currency)::text) AND (st.valuedate = py.valuedate))));


ALTER TABLE findata.repreconpaymentvsstatement OWNER TO findata;

--
-- TOC entry 327 (class 1259 OID 255215)
-- Name: repstatundif; Type: VIEW; Schema: findata; Owner: findata
--

CREATE VIEW findata.repstatundif AS
 SELECT entryqueue.id,
    entryqueue.batchid,
    entryqueue.requestorservice,
    entryqueue.correlationid,
    entryqueue.queuename,
    entryqueue.payload,
    'Waiting for Technical Investigation'::text AS status,
    ''::text AS sourcefilename,
    ''::text AS destinationfilename
   FROM findata.entryqueue
  WHERE (NOT ((entryqueue.correlationid)::text IN ( SELECT routedmessages.correlationid
           FROM findata.routedmessages)));


ALTER TABLE findata.repstatundif OWNER TO findata;

SET default_tablespace = findatatbs;

--
-- TOC entry 266 (class 1259 OID 63218)
-- Name: routingjobs; Type: TABLE; Schema: findata; Owner: tracker_owner; Tablespace: findatatbs
--

CREATE TABLE findata.routingjobs (
    id character varying(30) NOT NULL,
    status integer DEFAULT 0 NOT NULL,
    backout integer DEFAULT 0 NOT NULL,
    priority integer DEFAULT 10 NOT NULL,
    routingpoint character varying(50),
    function character varying(200) NOT NULL,
    userid integer,
    operationdetails character varying(140)
);


ALTER TABLE findata.routingjobs OWNER TO tracker_owner;

SET default_tablespace = '';

--
-- TOC entry 267 (class 1259 OID 63224)
-- Name: serviceperformance; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.serviceperformance (
    serviceid integer NOT NULL,
    insertdate timestamp without time zone NOT NULL,
    mintrxtime integer NOT NULL,
    maxtrxtime integer NOT NULL,
    meantrxtime integer NOT NULL,
    sequenceno numeric(10,0) NOT NULL,
    ioidentifier integer NOT NULL,
    sessionid integer NOT NULL,
    commitedtrx integer,
    abortedtrx integer
);


ALTER TABLE findata.serviceperformance OWNER TO findata;

--
-- TOC entry 269 (class 1259 OID 63233)
-- Name: tempbatchjobs; Type: TABLE; Schema: findata; Owner: findata
--

CREATE TABLE findata.tempbatchjobs (
    id character varying(30) NOT NULL,
    sequence numeric NOT NULL,
    batchid character varying(35) NOT NULL,
    xformitem character varying(4000) NOT NULL,
    correlationid character varying(30),
    feedback character varying(40)
);


ALTER TABLE findata.tempbatchjobs OWNER TO findata;


--
-- TOC entry 4422 (class 0 OID 63224)
-- Dependencies: 267
-- Data for Name: serviceperformance; Type: TABLE DATA; Schema: findata; Owner: findata
--

COPY findata.serviceperformance (serviceid, insertdate, mintrxtime, maxtrxtime, meantrxtime, sequenceno, ioidentifier, sessionid, commitedtrx, abortedtrx) FROM stdin;
1	2014-01-27 14:02:44.91	0	0	0	0	0	0	0	0
3	2014-01-27 14:02:51.71	0	0	0	0	0	0	0	0
10	2014-01-27 14:03:10.1	0	0	0	0	0	0	0	0
200	2014-01-27 14:03:16.09	0	0	0	0	0	0	0	0
201	2014-01-27 14:03:22.33	0	0	0	0	0	0	0	0
202	2014-02-24 16:15:58	0	0	0	0	0	0	0	0
203	2014-02-24 16:16:08	0	0	0	0	0	0	0	0
204	2014-04-04 16:48:48	0	0	0	0	0	0	0	0
300	2014-04-04 16:49:06	0	0	0	0	0	0	0	0
301	2014-04-04 16:49:22	0	0	0	0	0	0	0	0
400	2020-03-05 00:00:00	0	0	0	0	0	0	0	0
401	2020-03-10 00:00:00	0	0	0	0	0	0	0	0
20	2020-05-22 00:00:00	0	0	0	0	0	0	0	0
30	2020-05-22 13:51:01	0	0	0	0	0	0	0	0
402	2020-10-14 00:00:00	0	0	0	0	0	0	0	0
403	2020-10-15 11:18:12	0	0	0	0	0	0	0	0
\.



--
-- TOC entry 4493 (class 0 OID 0)
-- Dependencies: 252
-- Name: batchrequests_requestid_seq; Type: SEQUENCE SET; Schema: findata; Owner: findata
--

SELECT pg_catalog.setval('findata.batchrequests_requestid_seq', 1075, true);


--
-- TOC entry 4494 (class 0 OID 0)
-- Dependencies: 253
-- Name: commbatchseq; Type: SEQUENCE SET; Schema: findata; Owner: findata
--

SELECT pg_catalog.setval('findata.commbatchseq', 1169, true);


--
-- TOC entry 4205 (class 2606 OID 85101)
-- Name: batchjobs PK_BJ_BATCHID; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.batchjobs
    ADD CONSTRAINT "PK_BJ_BATCHID" PRIMARY KEY (batchid);


--
-- TOC entry 4209 (class 2606 OID 85103)
-- Name: batchrequests PK_BREQ_REQID; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.batchrequests
    ADD CONSTRAINT "PK_BREQ_REQID" PRIMARY KEY (id);


--
-- TOC entry 4211 (class 2606 OID 85105)
-- Name: entryqueue PK_EQ_GUID; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.entryqueue
    ADD CONSTRAINT "PK_EQ_GUID" PRIMARY KEY (id);


--
-- TOC entry 4214 (class 2606 OID 85107)
-- Name: history PK_HIST_GUID; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.history
    ADD CONSTRAINT "PK_HIST_GUID" PRIMARY KEY (id);


SET default_tablespace = findatatbs;

--
-- TOC entry 4222 (class 2606 OID 85121)
-- Name: mtcdttrfinitnothrtab PK_MTCRPPMTGEN_CORRELID; Type: CONSTRAINT; Schema: findata; Owner: findata; Tablespace: findatatbs
--

ALTER TABLE ONLY findata.mtcdttrfinitnothrtab
    ADD CONSTRAINT "PK_MTCRPPMTGEN_CORRELID" PRIMARY KEY (correlationid);


--
-- TOC entry 4226 (class 2606 OID 85123)
-- Name: mtcdttrfinitnsupptab PK_MTCRPPMTINV_CORRELID; Type: CONSTRAINT; Schema: findata; Owner: findata; Tablespace: findatatbs
--

ALTER TABLE ONLY findata.mtcdttrfinitnsupptab
    ADD CONSTRAINT "PK_MTCRPPMTINV_CORRELID" PRIMARY KEY (correlationid);


--
-- TOC entry 4224 (class 2606 OID 85125)
-- Name: mtcdttrfinitnsalatab PK_MTCRPPMTSAL_CORRELID; Type: CONSTRAINT; Schema: findata; Owner: findata; Tablespace: findatatbs
--

ALTER TABLE ONLY findata.mtcdttrfinitnsalatab
    ADD CONSTRAINT "PK_MTCRPPMTSAL_CORRELID" PRIMARY KEY (correlationid);


--
-- TOC entry 4228 (class 2606 OID 85127)
-- Name: mtcdttrfinitntaxstab PK_MTCRPPMTTAXDUT_CORRELID; Type: CONSTRAINT; Schema: findata; Owner: findata; Tablespace: findatatbs
--

ALTER TABLE ONLY findata.mtcdttrfinitntaxstab
    ADD CONSTRAINT "PK_MTCRPPMTTAXDUT_CORRELID" PRIMARY KEY (correlationid);


--
-- TOC entry 4230 (class 2606 OID 85129)
-- Name: mtcdttrfinitnvatxtab PK_MTCRPPMTVAT_CORRELID; Type: CONSTRAINT; Schema: findata; Owner: findata; Tablespace: findatatbs
--

ALTER TABLE ONLY findata.mtcdttrfinitnvatxtab
    ADD CONSTRAINT "PK_MTCRPPMTVAT_CORRELID" PRIMARY KEY (correlationid);


SET default_tablespace = '';

--
-- TOC entry 4237 (class 2606 OID 135537)
-- Name: mtfininvctab PK_MTFININVC_CORRELID; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.mtfininvctab
    ADD CONSTRAINT "PK_MTFININVC_CORRELID" PRIMARY KEY (correlationid);


--
-- TOC entry 4243 (class 2606 OID 2022592)
-- Name: repbalancesheet PK_REPBSHEET_ENTYEAR; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.repbalancesheet
    ADD CONSTRAINT "PK_REPBSHEET_ENTYEAR" PRIMARY KEY (entity, year);


--
-- TOC entry 4245 (class 2606 OID 2022601)
-- Name: repprofitandloss PK_REPROFITANDLOSS_ENTYEAR; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.repprofitandloss
    ADD CONSTRAINT "PK_REPROFITANDLOSS_ENTYEAR" PRIMARY KEY (entity, year);


--
-- TOC entry 4232 (class 2606 OID 85149)
-- Name: routingjobs PK_RJ_GUID; Type: CONSTRAINT; Schema: findata; Owner: tracker_owner
--

ALTER TABLE ONLY findata.routingjobs
    ADD CONSTRAINT "PK_RJ_GUID" PRIMARY KEY (id);


--
-- TOC entry 4216 (class 2606 OID 85151)
-- Name: routedmessages PK_RM_GUID; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.routedmessages
    ADD CONSTRAINT "PK_RM_GUID" PRIMARY KEY (id);


--
-- TOC entry 4234 (class 2606 OID 85153)
-- Name: serviceperformance PK_SERVPERF_SERVID; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.serviceperformance
    ADD CONSTRAINT "PK_SERVPERF_SERVID" PRIMARY KEY (serviceid);


--
-- TOC entry 4207 (class 2606 OID 85157)
-- Name: batchjobs UK_BJ_CONST; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.batchjobs
    ADD CONSTRAINT "UK_BJ_CONST" UNIQUE (initialbatchid, userid, messagecount, amount, batchuid);


--
-- TOC entry 4218 (class 2606 OID 85161)
-- Name: routedmessages UK_RM_CORRELID; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.routedmessages
    ADD CONSTRAINT "UK_RM_CORRELID" UNIQUE (correlationid);


--
-- TOC entry 4239 (class 2606 OID 2022569)
-- Name: bsloadhistory bsloadhistory_pkey; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.bsloadhistory
    ADD CONSTRAINT bsloadhistory_pkey PRIMARY KEY (id);


--
-- TOC entry 4247 (class 2606 OID 2031137)
-- Name: bsforecast pk_bsf_id; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.bsforecast
    ADD CONSTRAINT pk_bsf_id PRIMARY KEY (id);


SET default_tablespace = findatatbs;

--
-- TOC entry 4249 (class 2606 OID 2031146)
-- Name: cfcomparison pk_cfcomparison_id; Type: CONSTRAINT; Schema: findata; Owner: findata; Tablespace: findatatbs
--

ALTER TABLE ONLY findata.cfcomparison
    ADD CONSTRAINT pk_cfcomparison_id PRIMARY KEY (id);


--
-- TOC entry 4251 (class 2606 OID 2031157)
-- Name: cfforecast pk_cfforecast_id; Type: CONSTRAINT; Schema: findata; Owner: findata; Tablespace: findatatbs
--

ALTER TABLE ONLY findata.cfforecast
    ADD CONSTRAINT pk_cfforecast_id PRIMARY KEY (id);


--
-- TOC entry 4253 (class 2606 OID 2031164)
-- Name: cfforecastgendata pk_cfforecastgendata_id; Type: CONSTRAINT; Schema: findata; Owner: findata; Tablespace: findatatbs
--

ALTER TABLE ONLY findata.cfforecastgendata
    ADD CONSTRAINT pk_cfforecastgendata_id PRIMARY KEY (id);


--
-- TOC entry 4220 (class 2606 OID 85163)
-- Name: mtbktocstmrdbtcdttab pk_mtbkcstmr_correlid; Type: CONSTRAINT; Schema: findata; Owner: findata; Tablespace: findatatbs
--

ALTER TABLE ONLY findata.mtbktocstmrdbtcdttab
    ADD CONSTRAINT pk_mtbkcstmr_correlid PRIMARY KEY (correlationid);


SET default_tablespace = '';

--
-- TOC entry 4241 (class 2606 OID 2022584)
-- Name: plloadhistory plloadhistory_pkey; Type: CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.plloadhistory
    ADD CONSTRAINT plloadhistory_pkey PRIMARY KEY (id);


--
-- TOC entry 4212 (class 1259 OID 85190)
-- Name: UK_FB_CORRELID; Type: INDEX; Schema: findata; Owner: findata
--

CREATE UNIQUE INDEX "UK_FB_CORRELID" ON findata.feedbackagg USING btree (correlationid);


--
-- TOC entry 4235 (class 1259 OID 85191)
-- Name: idx_status; Type: INDEX; Schema: findata; Owner: findata
--

CREATE INDEX idx_status ON findata.status USING btree (correlationid);


--
-- TOC entry 4264 (class 2620 OID 101648)
-- Name: routingjobs trackerwatcher; Type: TRIGGER; Schema: findata; Owner: tracker_owner
--

CREATE TRIGGER trackerwatcher BEFORE DELETE ON findata.routingjobs FOR EACH ROW EXECUTE PROCEDURE findata.trg_saveprocjob();


--
-- TOC entry 4263 (class 2620 OID 85198)
-- Name: entryqueue trgaientryqueue; Type: TRIGGER; Schema: findata; Owner: findata
--

CREATE TRIGGER trgaientryqueue AFTER INSERT ON findata.entryqueue FOR EACH ROW EXECUTE PROCEDURE findata.trg_insertroutingjob();


--
-- TOC entry 4265 (class 2620 OID 2022571)
-- Name: bsloadhistory trginsertbs; Type: TRIGGER; Schema: findata; Owner: findata
--

CREATE TRIGGER trginsertbs AFTER INSERT OR UPDATE ON findata.bsloadhistory FOR EACH ROW EXECUTE PROCEDURE findata.trg_saverepbsdatajob();


--
-- TOC entry 4266 (class 2620 OID 2022585)
-- Name: plloadhistory trginsertprofitandloss; Type: TRIGGER; Schema: findata; Owner: findata
--

CREATE TRIGGER trginsertprofitandloss AFTER INSERT OR UPDATE ON findata.plloadhistory FOR EACH ROW EXECUTE PROCEDURE findata.trg_savereppldatajob();


--
-- TOC entry 4254 (class 2606 OID 85329)
-- Name: batchjobs FK_BJ_U_UID; Type: FK CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.batchjobs
    ADD CONSTRAINT "FK_BJ_U_UID" FOREIGN KEY (userid) REFERENCES fincfg.users(id);


--
-- TOC entry 4256 (class 2606 OID 98331)
-- Name: mtcdttrfinitnothrtab FK_MTCRPPMTGEN_RM_CORRELID; Type: FK CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.mtcdttrfinitnothrtab
    ADD CONSTRAINT "FK_MTCRPPMTGEN_RM_CORRELID" FOREIGN KEY (correlationid) REFERENCES findata.routedmessages(correlationid) ON DELETE CASCADE;


--
-- TOC entry 4258 (class 2606 OID 98341)
-- Name: mtcdttrfinitnsupptab FK_MTCRPPMTINV_RM_CORRELID; Type: FK CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.mtcdttrfinitnsupptab
    ADD CONSTRAINT "FK_MTCRPPMTINV_RM_CORRELID" FOREIGN KEY (correlationid) REFERENCES findata.routedmessages(correlationid) ON DELETE CASCADE;


--
-- TOC entry 4257 (class 2606 OID 98336)
-- Name: mtcdttrfinitnsalatab FK_MTCRPPMTSAL_RM_CORRELID; Type: FK CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.mtcdttrfinitnsalatab
    ADD CONSTRAINT "FK_MTCRPPMTSAL_RM_CORRELID" FOREIGN KEY (correlationid) REFERENCES findata.routedmessages(correlationid) ON DELETE CASCADE;


--
-- TOC entry 4259 (class 2606 OID 98321)
-- Name: mtcdttrfinitntaxstab FK_MTCRPPMTTAXDUT_RM_CORRELID; Type: FK CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.mtcdttrfinitntaxstab
    ADD CONSTRAINT "FK_MTCRPPMTTAXDUT_RM_CORRELID" FOREIGN KEY (correlationid) REFERENCES findata.routedmessages(correlationid) ON DELETE CASCADE;


--
-- TOC entry 4260 (class 2606 OID 98326)
-- Name: mtcdttrfinitnvatxtab FK_MTCRPPMTVAT_RM_CORRELID; Type: FK CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.mtcdttrfinitnvatxtab
    ADD CONSTRAINT "FK_MTCRPPMTVAT_RM_CORRELID" FOREIGN KEY (correlationid) REFERENCES findata.routedmessages(correlationid) ON DELETE CASCADE;


--
-- TOC entry 4262 (class 2606 OID 135538)
-- Name: mtfininvctab FK_MTFININVC_RM_CORRELID; Type: FK CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.mtfininvctab
    ADD CONSTRAINT "FK_MTFININVC_RM_CORRELID" FOREIGN KEY (correlationid) REFERENCES findata.routedmessages(correlationid);


--
-- TOC entry 4261 (class 2606 OID 85439)
-- Name: tempbatchjobs FK_TBJ_BJ_BATCHID; Type: FK CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.tempbatchjobs
    ADD CONSTRAINT "FK_TBJ_BJ_BATCHID" FOREIGN KEY (batchid) REFERENCES findata.batchjobs(batchid);


--
-- TOC entry 4255 (class 2606 OID 85444)
-- Name: mtbktocstmrdbtcdttab fk_mtbkcstmr_rm_correlid; Type: FK CONSTRAINT; Schema: findata; Owner: findata
--

ALTER TABLE ONLY findata.mtbktocstmrdbtcdttab
    ADD CONSTRAINT fk_mtbkcstmr_rm_correlid FOREIGN KEY (correlationid) REFERENCES findata.routedmessages(correlationid);


--
-- TOC entry 4439 (class 0 OID 0)
-- Dependencies: 15
-- Name: SCHEMA findata; Type: ACL; Schema: -; Owner: findata
--

GRANT USAGE ON SCHEMA findata TO finuiuser;
GRANT USAGE ON SCHEMA findata TO finconnect;


--
-- TOC entry 4440 (class 0 OID 0)
-- Dependencies: 446
-- Name: FUNCTION computebsforecast(inentity character varying, inrealisebsyear integer, inhistoricalbsyear integer, inforecastbsyear integer, inuserid integer); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.computebsforecast(inentity character varying, inrealisebsyear integer, inhistoricalbsyear integer, inforecastbsyear integer, inuserid integer) TO finuiuser;


--
-- TOC entry 4441 (class 0 OID 0)
-- Dependencies: 444
-- Name: FUNCTION createroutingjob(inqueuename character varying, inaction character varying, inreason character varying, inactiondetails character varying, inmsgtype character varying, inmsgid character varying, ingroupkey character varying, intimekey character varying, infield1val character varying, infield2val character varying, infield3val character varying, infield4val character varying, infield5val character varying, inuserid integer, intxids character varying[]); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.createroutingjob(inqueuename character varying, inaction character varying, inreason character varying, inactiondetails character varying, inmsgtype character varying, inmsgid character varying, ingroupkey character varying, intimekey character varying, infield1val character varying, infield2val character varying, infield3val character varying, infield4val character varying, infield5val character varying, inuserid integer, intxids character varying[]) TO finuiuser;


--
-- TOC entry 4442 (class 0 OID 0)
-- Dependencies: 459
-- Name: FUNCTION getbalancesheetdynamic(inyearmin integer, inyearmax integer, inindicatorsid integer[], inentity character varying); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.getbalancesheetdynamic(inyearmin integer, inyearmax integer, inindicatorsid integer[], inentity character varying) TO finuiuser;


--
-- TOC entry 4443 (class 0 OID 0)
-- Dependencies: 462
-- Name: FUNCTION getbskpis(inentity character varying, inyear integer, OUT outretcursor refcursor); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.getbskpis(inentity character varying, inyear integer, OUT outretcursor refcursor) TO finuiuser;


--
-- TOC entry 4444 (class 0 OID 0)
-- Dependencies: 359
-- Name: FUNCTION getbusinessareabyid(incorelid character varying); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.getbusinessareabyid(incorelid character varying) TO fintrack;


--
-- TOC entry 4445 (class 0 OID 0)
-- Dependencies: 447
-- Name: FUNCTION getcfcomparison(inentity character varying, incfforecastdate date, OUT outretcursor refcursor); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.getcfcomparison(inentity character varying, incfforecastdate date, OUT outretcursor refcursor) TO finuiuser;


--
-- TOC entry 4446 (class 0 OID 0)
-- Dependencies: 443
-- Name: FUNCTION getcfforest(inentity character varying, incfforecastdate date); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.getcfforest(inentity character varying, incfforecastdate date) TO finuiuser;


--
-- TOC entry 4447 (class 0 OID 0)
-- Dependencies: 361
-- Name: FUNCTION getgroupsformtqueue(inqueuename character varying, inmsgtype character varying, inamount numeric, inreference character varying, OUT outretcursor refcursor); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.getgroupsformtqueue(inqueuename character varying, inmsgtype character varying, inamount numeric, inreference character varying, OUT outretcursor refcursor) TO finuiuser;
GRANT ALL ON FUNCTION findata.getgroupsformtqueue(inqueuename character varying, inmsgtype character varying, inamount numeric, inreference character varying, OUT outretcursor refcursor) TO finat WITH GRANT OPTION;


--
-- TOC entry 4448 (class 0 OID 0)
-- Dependencies: 406
-- Name: FUNCTION getqueuetxno(OUT outretcursor refcursor); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.getqueuetxno(OUT outretcursor refcursor) TO finuiuser;


--
-- TOC entry 4449 (class 0 OID 0)
-- Dependencies: 407
-- Name: FUNCTION getstatus(incorrelid character varying); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.getstatus(incorrelid character varying) TO finuiuser;


--
-- TOC entry 4450 (class 0 OID 0)
-- Dependencies: 461
-- Name: FUNCTION trg_savereppldatajob(); Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON FUNCTION findata.trg_savereppldatajob() TO finuiuser;


--
-- TOC entry 4451 (class 0 OID 0)
-- Dependencies: 250
-- Name: TABLE batchjobs; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.batchjobs TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.batchjobs TO fintest;


--
-- TOC entry 4452 (class 0 OID 0)
-- Dependencies: 251
-- Name: TABLE batchrequests; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.batchrequests TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.batchrequests TO fintest;


--
-- TOC entry 4453 (class 0 OID 0)
-- Dependencies: 252
-- Name: SEQUENCE batchrequests_requestid_seq; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,USAGE ON SEQUENCE findata.batchrequests_requestid_seq TO finuiuser;


--
-- TOC entry 4454 (class 0 OID 0)
-- Dependencies: 341
-- Name: TABLE bsforecast; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.bsforecast TO finuiuser;


--
-- TOC entry 4455 (class 0 OID 0)
-- Dependencies: 334
-- Name: TABLE plloadhistory; Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON TABLE findata.plloadhistory TO finuiuser;


--
-- TOC entry 4456 (class 0 OID 0)
-- Dependencies: 345
-- Name: TABLE bsforecastcomparison; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.bsforecastcomparison TO finuiuser;


--
-- TOC entry 4457 (class 0 OID 0)
-- Dependencies: 333
-- Name: TABLE bsloadhistory; Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON TABLE findata.bsloadhistory TO finuiuser;


--
-- TOC entry 4458 (class 0 OID 0)
-- Dependencies: 342
-- Name: TABLE cfcomparison; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.cfcomparison TO finuiuser;


--
-- TOC entry 4459 (class 0 OID 0)
-- Dependencies: 343
-- Name: TABLE cfforecast; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.cfforecast TO finuiuser;


--
-- TOC entry 4460 (class 0 OID 0)
-- Dependencies: 344
-- Name: TABLE cfforecastgendata; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.cfforecastgendata TO finuiuser;


--
-- TOC entry 4461 (class 0 OID 0)
-- Dependencies: 254
-- Name: TABLE entryqueue; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.entryqueue TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.entryqueue TO fintest;


--
-- TOC entry 4462 (class 0 OID 0)
-- Dependencies: 255
-- Name: TABLE feedbackagg; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.feedbackagg TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.feedbackagg TO fintest;


--
-- TOC entry 4463 (class 0 OID 0)
-- Dependencies: 256
-- Name: TABLE history; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.history TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.history TO fintest;


--
-- TOC entry 4464 (class 0 OID 0)
-- Dependencies: 257
-- Name: TABLE messagehashes; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.messagehashes TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.messagehashes TO fintest;


--
-- TOC entry 4465 (class 0 OID 0)
-- Dependencies: 258
-- Name: TABLE routedmessages; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.routedmessages TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.routedmessages TO fintest;
GRANT SELECT ON TABLE findata.routedmessages TO fintrack;


--
-- TOC entry 4466 (class 0 OID 0)
-- Dependencies: 285
-- Name: TABLE mtbktocstmrdbtcdtview; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,REFERENCES,DELETE,TRIGGER,UPDATE ON TABLE findata.mtbktocstmrdbtcdtview TO PUBLIC;
GRANT SELECT ON TABLE findata.mtbktocstmrdbtcdtview TO finuiuser;


--
-- TOC entry 4467 (class 0 OID 0)
-- Dependencies: 260
-- Name: TABLE mtcdttrfinitnothrtab; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.mtcdttrfinitnothrtab TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.mtcdttrfinitnothrtab TO fintest;


--
-- TOC entry 4468 (class 0 OID 0)
-- Dependencies: 290
-- Name: TABLE mtcdttrfinitnothrview; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.mtcdttrfinitnothrview TO finuiuser;


--
-- TOC entry 4469 (class 0 OID 0)
-- Dependencies: 261
-- Name: TABLE mtcdttrfinitnsalatab; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.mtcdttrfinitnsalatab TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.mtcdttrfinitnsalatab TO fintest;


--
-- TOC entry 4470 (class 0 OID 0)
-- Dependencies: 287
-- Name: TABLE mtcdttrfinitnsalaview; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.mtcdttrfinitnsalaview TO finuiuser;


--
-- TOC entry 4471 (class 0 OID 0)
-- Dependencies: 262
-- Name: TABLE mtcdttrfinitnsupptab; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.mtcdttrfinitnsupptab TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.mtcdttrfinitnsupptab TO fintest;


--
-- TOC entry 4472 (class 0 OID 0)
-- Dependencies: 288
-- Name: TABLE mtcdttrfinitnsuppview; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.mtcdttrfinitnsuppview TO finuiuser;


--
-- TOC entry 4473 (class 0 OID 0)
-- Dependencies: 263
-- Name: TABLE mtcdttrfinitntaxstab; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.mtcdttrfinitntaxstab TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.mtcdttrfinitntaxstab TO fintest;


--
-- TOC entry 4474 (class 0 OID 0)
-- Dependencies: 289
-- Name: TABLE mtcdttrfinitntaxsview; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.mtcdttrfinitntaxsview TO finuiuser;


--
-- TOC entry 4475 (class 0 OID 0)
-- Dependencies: 264
-- Name: TABLE mtcdttrfinitnvatxtab; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.mtcdttrfinitnvatxtab TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.mtcdttrfinitnvatxtab TO fintest;


--
-- TOC entry 4476 (class 0 OID 0)
-- Dependencies: 286
-- Name: TABLE mtcdttrfinitnvatxview; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.mtcdttrfinitnvatxview TO finuiuser;


--
-- TOC entry 4477 (class 0 OID 0)
-- Dependencies: 284
-- Name: TABLE mtfininvcview; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.mtfininvcview TO finuiuser;


--
-- TOC entry 4478 (class 0 OID 0)
-- Dependencies: 265
-- Name: TABLE mtundefinedview; Type: ACL; Schema: findata; Owner: postgres
--

GRANT ALL ON TABLE findata.mtundefinedview TO finuiuser;


--
-- TOC entry 4479 (class 0 OID 0)
-- Dependencies: 335
-- Name: TABLE repbalancesheet; Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON TABLE findata.repbalancesheet TO finuiuser;


--
-- TOC entry 4480 (class 0 OID 0)
-- Dependencies: 268
-- Name: TABLE status; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.status TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.status TO fintest;
GRANT SELECT ON TABLE findata.status TO fintrack;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.status TO finat;
GRANT INSERT ON TABLE findata.status TO finconnect;


--
-- TOC entry 4481 (class 0 OID 0)
-- Dependencies: 340
-- Name: TABLE repevents; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.repevents TO finuiuser;


--
-- TOC entry 4482 (class 0 OID 0)
-- Dependencies: 336
-- Name: TABLE repprofitandloss; Type: ACL; Schema: findata; Owner: findata
--

GRANT ALL ON TABLE findata.repprofitandloss TO finuiuser;


--
-- TOC entry 4483 (class 0 OID 0)
-- Dependencies: 337
-- Name: TABLE repstatinvc; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.repstatinvc TO finuiuser;


--
-- TOC entry 4484 (class 0 OID 0)
-- Dependencies: 315
-- Name: TABLE repstatstmt; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.repstatstmt TO finuiuser;


--
-- TOC entry 4485 (class 0 OID 0)
-- Dependencies: 338
-- Name: TABLE repreconinvissvsstatement; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.repreconinvissvsstatement TO finuiuser;


--
-- TOC entry 4486 (class 0 OID 0)
-- Dependencies: 339
-- Name: TABLE repreconinvsuppvsstatement; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.repreconinvsuppvsstatement TO finuiuser;


--
-- TOC entry 4487 (class 0 OID 0)
-- Dependencies: 314
-- Name: TABLE repstatpymt; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.repstatpymt TO finuiuser;


--
-- TOC entry 4488 (class 0 OID 0)
-- Dependencies: 328
-- Name: TABLE repreconpaymentvsstatement; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.repreconpaymentvsstatement TO finuiuser;


--
-- TOC entry 4489 (class 0 OID 0)
-- Dependencies: 327
-- Name: TABLE repstatundif; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT ON TABLE findata.repstatundif TO finuiuser;


--
-- TOC entry 4490 (class 0 OID 0)
-- Dependencies: 266
-- Name: TABLE routingjobs; Type: ACL; Schema: findata; Owner: tracker_owner
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.routingjobs TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.routingjobs TO fintest;
GRANT ALL ON TABLE findata.routingjobs TO fintrack;


--
-- TOC entry 4491 (class 0 OID 0)
-- Dependencies: 267
-- Name: TABLE serviceperformance; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.serviceperformance TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.serviceperformance TO fintest;


--
-- TOC entry 4492 (class 0 OID 0)
-- Dependencies: 269
-- Name: TABLE tempbatchjobs; Type: ACL; Schema: findata; Owner: findata
--

GRANT SELECT,INSERT,DELETE,UPDATE ON TABLE findata.tempbatchjobs TO finuiuser;
GRANT SELECT,INSERT,UPDATE ON TABLE findata.tempbatchjobs TO fintest;


-- Completed on 2021-11-24 13:47:29

--
-- PostgreSQL database dump complete
--

